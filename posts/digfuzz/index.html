<!doctype html><html itemscope itemtype=http://schema.org/WebPage lang=zh-CN><head><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1,maximum-scale=2"><meta name=robots content="noodp"><title>Digfuzz工具论文调研 | Leehow的小站</title><meta name=author content="Leehow">
<meta name=description content="Digfuzz工具论文调研：《Send Hardest Problems My Way: Probabilistic Path Prioritization for Hybrid Fuzzing》"><meta name=keywords content='论文,符号执行,模糊测试'><meta itemprop=name content="Digfuzz工具论文调研"><meta itemprop=description content="Digfuzz工具论文调研：《Send Hardest Problems My Way: Probabilistic Path Prioritization for Hybrid Fuzzing》"><meta itemprop=datePublished content="2023-12-10T17:04:08+08:00"><meta itemprop=dateModified content="2025-01-24T00:48:27+00:00"><meta itemprop=wordCount content="14668"><meta itemprop=image content="https://cdn.haoyep.com/gh/leegical/Blog_img/cdnimg/weblogo.png"><meta itemprop=keywords content="论文,符号执行,模糊测试"><meta property="og:url" content="https://www.haoyep.com/posts/digfuzz/"><meta property="og:site_name" content="Leehow的小站"><meta property="og:title" content="Digfuzz工具论文调研"><meta property="og:description" content="Digfuzz工具论文调研：《Send Hardest Problems My Way: Probabilistic Path Prioritization for Hybrid Fuzzing》"><meta property="og:locale" content="zh_CN"><meta property="og:type" content="article"><meta property="article:section" content="posts"><meta property="article:published_time" content="2023-12-10T17:04:08+08:00"><meta property="article:modified_time" content="2025-01-24T00:48:27+00:00"><meta property="article:tag" content="论文"><meta property="article:tag" content="符号执行"><meta property="article:tag" content="模糊测试"><meta property="og:image" content="https://cdn.haoyep.com/gh/leegical/Blog_img/cdnimg/weblogo.png"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="https://cdn.haoyep.com/gh/leegical/Blog_img/cdnimg/weblogo.png"><meta name=twitter:title content="Digfuzz工具论文调研"><meta name=twitter:description content="Digfuzz工具论文调研：《Send Hardest Problems My Way: Probabilistic Path Prioritization for Hybrid Fuzzing》"><meta name=application-name content="Leehow"><meta name=apple-mobile-web-app-title content="Leehow"><meta name=theme-color data-light=#f8f8f8 data-dark=#252627 content="#f8f8f8"><meta name=msapplication-TileColor content="#da532c"><link rel=icon href=https://cdn.haoyep.com/gh/leegical/Blog_img/cdnimg/favicon.svg><link rel=apple-touch-icon sizes=180x180 href=/apple-touch-icon.png><link rel=mask-icon href=/safari-pinned-tab.svg color=#5bbad5><link rel=manifest href=/site.webmanifest><link rel=canonical type=text/html href=https://www.haoyep.com/posts/digfuzz/ title="Digfuzz工具论文调研 | Leehow的小站"><link rel=prev type=text/html href=https://www.haoyep.com/about/ title=关于><link rel=next type=text/html href=https://www.haoyep.com/posts/github-graph-beds/ title="使用PicGo + GitHub 搭建 Obsidian 图床"><link rel=alternate type=text/markdown href=https://www.haoyep.com/posts/digfuzz/index.md title="Digfuzz工具论文调研 | Leehow的小站"><link rel=stylesheet href=/css/style.min.css><link rel=preload href=https://unpkg.com/@fortawesome/fontawesome-free@6.7.1/css/all.min.css as=style onload='this.removeAttribute("onload"),this.rel="stylesheet"'><noscript><link rel=stylesheet href=https://unpkg.com/@fortawesome/fontawesome-free@6.7.1/css/all.min.css></noscript><link rel=preload href=https://unpkg.com/animate.css@4.1.1/animate.min.css as=style onload='this.removeAttribute("onload"),this.rel="stylesheet"'><noscript><link rel=stylesheet href=https://unpkg.com/animate.css@4.1.1/animate.min.css></noscript><script type=application/ld+json>{"@context":"http://schema.org","@type":"BlogPosting","headline":"Digfuzz工具论文调研","inLanguage":"zh-CN","mainEntityOfPage":{"@type":"WebPage","@id":"https:\/\/www.haoyep.com\/posts\/digfuzz\/"},"image":["https:\/\/cdn.haoyep.com\/gh\/leegical\/Blog_img\/cdnimg\/202312161447739.ico"],"genre":"posts","keywords":"论文, 符号执行, 模糊测试","wordcount":14668,"url":"https:\/\/www.haoyep.com\/posts\/digfuzz\/","datePublished":"2023-12-10T17:04:08+08:00","dateModified":"2025-01-24T00:48:27+00:00","license":"本站内容采用 CC BY-NC-SA 4.0 国际许可协议。","publisher":{"@type":"Organization","name":"Leehow","logo":"https:\/\/cdn.haoyep.com\/gh\/leegical\/Blog_img\/cdnimg\/weblogo.png"},"author":{"@type":"Person","name":"Leehow"},"description":"Digfuzz工具论文调研：《Send Hardest Problems My Way: Probabilistic Path Prioritization for Hybrid Fuzzing》"}</script><script src=/js/head/color-scheme.min.js></script></head><body data-header-desktop=sticky data-header-mobile=auto><div class=wrapper data-page-style=normal><header class="desktop animate__faster" id=header-desktop><div class=header-wrapper><div class=header-title><a href=/ title=Leehow的小站><img loading=lazy src=/pokeball.svg alt=Leehow的小站 data-title=Leehow的小站 width=26 height=26 class=logo style="background:url(/images/loading.min.svg)no-repeat 50%" onload='this.title=this.dataset.title;for(const e of["style","data-title","onerror","onload"])this.removeAttribute(e);this.dataset.lazyloaded=""' onerror='this.title=this.dataset.title;for(const e of["style","data-title","onerror","onload"])this.removeAttribute(e)'><span class=header-title-text>Leehow</span></a><span class=header-subtitle>好耶！</span></div><nav><ul class=menu><li class="menu-item has-children"><a class=menu-link href=/archives/><i class="fa-solid fa-feather fa-fw fa-sm" aria-hidden=true></i> 文章</a><i class="dropdown-icon fa-solid fa-chevron-down" aria-hidden=true></i><ul class=sub-menu><li class=menu-item><a class=menu-link href=/categories/><i class="fa-solid fa-folder-tree fa-fw fa-sm" aria-hidden=true></i> 分类</a></li><li class=menu-item><a class=menu-link href=/collections/><i class="fa-solid fa-layer-group fa-fw fa-sm" aria-hidden=true></i> 合集</a></li><li class=menu-item><a class=menu-link href=/tags/><i class="fa-solid fa-tags fa-fw fa-sm" aria-hidden=true></i> 标签</a></li></ul></li><li class=menu-item><a class=menu-link href=/friends/ title=友情链接><i class="fa-solid fa-users fa-fw fa-sm" aria-hidden=true></i> 友链</a></li><li class=menu-item><a class=menu-link href=/guestbook/><i class="fa-solid fa-comment-dots fa-fw fa-sm" aria-hidden=true></i> 留言</a></li><li class=menu-item><a class=menu-link href=/about/><i class="fa-solid fa-quote-left fa-fw fa-sm" aria-hidden=true></i> 关于</a></li><li class="menu-item delimiter"></li><li class="menu-item search" id=search-desktop><input type=text placeholder=搜索文章标题或内容…… id=search-input-desktop>
<a href=javascript:void(0); class="search-button search-toggle" id=search-toggle-desktop title=搜索><i class="fa-solid fa-search fa-fw" aria-hidden=true></i>
</a><a href=javascript:void(0); class="search-button search-clear" id=search-clear-desktop title=清空><i class="fa-solid fa-times-circle fa-fw" aria-hidden=true></i>
</a><span class="search-button search-loading" id=search-loading-desktop><i class="fa-solid fa-spinner fa-fw fa-spin" aria-hidden=true></i></span></li><li class="menu-item theme-switch" title=切换主题><i class="fa-solid fa-adjust fa-fw" aria-hidden=true></i></li><li class="menu-item language-switch auto d-none" aria-hidden=true><span role=button aria-label=选择语言 title=选择语言><i class="fa-solid fa-language fa-fw" aria-hidden=true></i></span><ul class=sub-menu><li class="menu-item active" data-type=artificial><a href=/posts/digfuzz/ data-lang=zh-CN class="menu-link text-secondary" title=简体中文><i class="fa-solid fa-person fa-fw fa-sm" aria-hidden=true></i> 简体中文</a></li><li class=menu-item-divider aria-hidden=true></li><li class=menu-item data-type=machine><a data-lang=english class=menu-link title=English><i class="fa-solid fa-robot fa-fw fa-sm" aria-hidden=true></i> English</a></li><li class=menu-item data-type=machine><a data-lang=chinese_traditional class=menu-link title=繁體中文><i class="fa-solid fa-robot fa-fw fa-sm" aria-hidden=true></i> 繁體中文</a></li></ul></li></ul></nav></div></header><header class="mobile animate__faster" id=header-mobile><div class=header-container><div class=header-wrapper><div class=header-title><a href=/ title=Leehow的小站><img loading=lazy src=/pokeball.svg alt=Leehow的小站 data-title=Leehow的小站 width=26 height=26 class=logo style="background:url(/images/loading.min.svg)no-repeat 50%" onload='this.title=this.dataset.title;for(const e of["style","data-title","onerror","onload"])this.removeAttribute(e);this.dataset.lazyloaded=""' onerror='this.title=this.dataset.title;for(const e of["style","data-title","onerror","onload"])this.removeAttribute(e)'><span class=header-title-text>Leehow</span></a><span class=header-subtitle>好耶！</span></div><div class=menu-toggle id=menu-toggle-mobile><span></span><span></span><span></span></div></div><nav><ul class=menu id=menu-mobile><li class=search-wrapper><div class="search mobile" id=search-mobile><input type=text placeholder=搜索文章标题或内容…… id=search-input-mobile>
<a href=javascript:void(0); class="search-button search-toggle" id=search-toggle-mobile title=搜索><i class="fa-solid fa-search fa-fw" aria-hidden=true></i>
</a><a href=javascript:void(0); class="search-button search-clear" id=search-clear-mobile title=清空><i class="fa-solid fa-times-circle fa-fw" aria-hidden=true></i>
</a><span class="search-button search-loading" id=search-loading-mobile><i class="fa-solid fa-spinner fa-fw fa-spin" aria-hidden=true></i></span></div><a href=javascript:void(0); class=search-cancel id=search-cancel-mobile>取消</a></li><li class=menu-item><span class=nested-item><a class=menu-link href=/archives/><i class="fa-solid fa-feather fa-fw fa-sm" aria-hidden=true></i> 文章</a>
<i class="dropdown-icon fa-solid fa-chevron-right" aria-hidden=true></i></span><ul class=sub-menu><li class=menu-item><a class=menu-link href=/categories/><i class="fa-solid fa-folder-tree fa-fw fa-sm" aria-hidden=true></i> 分类</a></li><li class=menu-item><a class=menu-link href=/collections/><i class="fa-solid fa-layer-group fa-fw fa-sm" aria-hidden=true></i> 合集</a></li><li class=menu-item><a class=menu-link href=/tags/><i class="fa-solid fa-tags fa-fw fa-sm" aria-hidden=true></i> 标签</a></li></ul></li><li class=menu-item><a class=menu-link href=/friends/ title=友情链接><i class="fa-solid fa-users fa-fw fa-sm" aria-hidden=true></i> 友链</a></li><li class=menu-item><a class=menu-link href=/guestbook/><i class="fa-solid fa-comment-dots fa-fw fa-sm" aria-hidden=true></i> 留言</a></li><li class=menu-item><a class=menu-link href=/about/><i class="fa-solid fa-quote-left fa-fw fa-sm" aria-hidden=true></i> 关于</a></li><li class="menu-item menu-system"><span class="menu-system-item theme-switch" title=切换主题><i class="fa-solid fa-adjust fa-fw" aria-hidden=true></i></span><span id=translate class="menu-system-item language-switch auto d-none" aria-hidden=true>
<span role=button aria-label=选择语言 title=选择语言 data-current=简体中文>简体中文<i class="dropdown-icon fa-solid fa-chevron-down" aria-hidden=true></i></span></span></li></ul></nav></div></header><div class="search-dropdown desktop"><div id=search-dropdown-desktop></div></div><div class="search-dropdown mobile"><div id=search-dropdown-mobile></div></div><nav aria-label=breadcrumb class="breadcrumb-container sticky"><ol class=breadcrumb><li class=breadcrumb-item data-separator=/><a href=/posts/ title=posts>文章</a></li><li class=breadcrumb-item data-separator=/><a href=/posts/%E7%A7%91%E7%A0%94/ title=科研用到的工具、论文、idea等。>科研随想录</a></li><li class="breadcrumb-item active" data-separator=/ aria-current=page>Digfuzz工具论文调研</li></ol></nav><main class=container><aside class="aside-collection animate__animated animate__fadeIn animate__faster" aria-label=合集></aside><article class="page single"><div class=header><h1 class="single-title animate__animated animate__flipInX"><span>Digfuzz工具论文调研</span></h1></div><div class=post-meta><div class=post-meta-line><span class=post-author><a href=https://www.haoyep.com/ title=作者 target=_blank rel="external nofollow noopener noreferrer author" class=author><img loading=lazy src="https://dn-qiniu-avatar.qbox.me/avatar/867c2859fc58e987cb357c7a67ac01cb?s=32&amp;d=mp" alt=Leehow data-title=Leehow width=20 height=20 class=avatar style="background:url(/images/loading.min.svg)no-repeat 50%" onload='this.title=this.dataset.title;for(const e of["style","data-title","onerror","onload"])this.removeAttribute(e);this.dataset.lazyloaded=""' onerror='this.title=this.dataset.title;for(const e of["style","data-title","onerror","onload"])this.removeAttribute(e)'>&nbsp;Leehow</a></span><span class=post-included-in>&nbsp;收录于 <a href=/categories/%E7%A7%91%E7%A0%94/ class=post-category title="分类 - 科研"><i class="fa-regular fa-folder fa-fw" aria-hidden=true></i> 科研</a></span></div><div class=post-meta-line><span title="发布于 2023-12-10 17:04:08"><i class="fa-solid fa-calendar-days fa-fw me-1" aria-hidden=true></i><time datetime=2023-12-10>2023-12-10</time></span>&nbsp;<span title="更新于 2025-01-24 00:48:27"><i class="fa-regular fa-calendar-check fa-fw me-1" aria-hidden=true></i><time datetime=2025-01-24>2025-01-24</time></span>&nbsp;<span title="14668 字"><i class="fa-solid fa-pencil-alt fa-fw me-1" aria-hidden=true></i>约 14700 字</span>&nbsp;<span><i class="fa-regular fa-clock fa-fw me-1" aria-hidden=true></i>预计阅读 30 分钟</span>&nbsp;<span id=busuanzi_container_page_pv class="busuanzi_visitors comment-visitors" data-flag-title=Digfuzz工具论文调研><i class="fa-regular fa-eye fa-fw me-1" aria-hidden=true></i><span id=busuanzi_value_page_pv>-</span>&nbsp;次阅读
</span>&nbsp;</div></div><div class=featured-image><img loading=lazy src=https://cdn.haoyep.com/gh/leegical/Blog_img/cdnimg/202401171503941.png alt=https://cdn.haoyep.com/gh/leegical/Blog_img/cdnimg/202401171503941.png data-title="Digfuzz工具论文调研：《Send Hardest Problems My Way: Probabilistic Path Prioritization for Hybrid Fuzzing》" style="background:url(/images/loading.min.svg)no-repeat 50%" onload='this.title=this.dataset.title;for(const e of["style","data-title","onerror","onload"])this.removeAttribute(e);this.dataset.lazyloaded=""' onerror='this.title=this.dataset.title;for(const e of["style","data-title","onerror","onload"])this.removeAttribute(e)'></div><div class="details toc" id=toc-static data-kept=false><div class="details-summary toc-title"><span>目录</span>
<span><i class="details-icon fa-solid fa-angle-right" aria-hidden=true></i></span></div><div class="details-content toc-content" id=toc-content-static><nav id=TableOfContents><ol><li><a href=#背景知识>背景知识</a><ol><li><a href=#fuzzing-的分类>fuzzing 的分类</a><ol><li><a href=#黑盒black-boxfuzzer>黑盒（black-box）fuzzer</a></li><li><a href=#白盒white-boxfuzzer>白盒（white-box）fuzzer</a></li><li><a href=#灰盒grey-boxfuzzer>灰盒（grey-box）fuzzer</a></li><li><a href=#dynamic-symbolic-execution>Dynamic Symbolic Execution</a></li></ol></li></ol></li><li><a href=#abstract>Abstract</a></li><li><a href=#introduction>Introduction</a></li><li><a href=#background-and-motivation>Background And Motivation</a><ol><li><a href=#demand-launch>Demand Launch</a><ol><li><a href=#观察>观察</a></li><li><a href=#局限性>局限性</a></li></ol></li><li><a href=#optimal-switch>Optimal Switch</a><ol><li><a href=#观察-1>观察</a></li><li><a href=#限制>限制</a></li></ol></li></ol></li><li><a href=#probabilistic-path-prioritization-guided-by-monte-carlo>PROBABILISTIC PATH PRIORITIZATION GUIDED BY MONTE-CARLO</a><ol><li><a href=#key-challenge>Key Challenge</a></li><li><a href=#monte-carlo-based-probabilistic-path-prioritization-model>Monte Carlo Based Probabilistic Path Prioritization Model</a><ol><li><a href=#probability-for-each-branch>Probability for each branch</a></li><li><a href=#probability-for-each-path>Probability for each path</a></li></ol></li><li><a href=#mcp3based-execution-tree>$MCP^3$ based Execution Tree</a><ol><li><a href=#定义1><strong>定义1</strong></a></li></ol></li></ol></li><li><a href=#design-and-implementation>Design and Implementation</a><ol><li><a href=#system-overview>System Overview</a></li><li><a href=#execution-sampling>Execution Sampling</a></li><li><a href=#execution-tree-construction>Execution Tree Construction</a></li><li><a href=#probabilistic-path-prioritization>Probabilistic Path Prioritization</a></li></ol></li><li><a href=#discussion>Discussion</a><ol><li><a href=#threats-to-validity>Threats to Validity</a></li><li><a href=#limitations>Limitations</a></li></ol></li><li><a href=#related-work>Related Work</a><ol><li><a href=#hybrid-fuzzing-system>Hybrid fuzzing system</a></li><li><a href=#path-prioritization-in-symbolic-execution>Path prioritization in symbolic execution</a></li><li><a href=#seed-scheduling-in-fuzzing>Seed scheduling in fuzzing</a></li></ol></li><li><a href=#conclusion>Conclusion</a></li></ol></nav></div></div><div class=content id=content data-end-flag=（本文完）><p>论文调研：《Send Hardest Problems My Way: Probabilistic Path Prioritization for Hybrid Fuzzing》</p><h2 id=背景知识 class=heading-element><span>1 背景知识</span>
<a href=#%e8%83%8c%e6%99%af%e7%9f%a5%e8%af%86 class=heading-mark><svg class="octicon octicon-link" viewBox="0 0 16 16" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5.0 114.95 4.95l-2.5 2.5a3.5 3.5.0 01-4.95.0.751.751.0 01.018-1.042.751.751.0 011.042-.018 1.998 1.998.0 002.83.0l2.5-2.5a2.002 2.002.0 00-2.83-2.83l-1.25 1.25a.751.751.0 01-1.042-.018.751.751.0 01-.018-1.042zm-4.69 9.64a1.998 1.998.0 002.83.0l1.25-1.25a.751.751.0 011.042.018.751.751.0 01.018 1.042l-1.25 1.25a3.5 3.5.0 11-4.95-4.95l2.5-2.5a3.5 3.5.0 014.95.0.751.751.0 01-.018 1.042.751.751.0 01-1.042.018 1.998 1.998.0 00-2.83.0l-2.5 2.5a1.998 1.998.0 000 2.83z"/></svg></a></h2><div class="alert alert-note"><p class=alert-title><svg class="icon" viewBox="0 0 16 16" width="16" height="16"><path d="M0 8a8 8 0 1116 0A8 8 0 010 8zm8-6.5a6.5 6.5.0 100 13 6.5 6.5.0 000-13zM6.5 7.75A.75.75.0 017.25 7h1a.75.75.0 01.75.75v2.75h.25a.75.75.0 010 1.5h-2a.75.75.0 010-1.5h.25v-2h-.25a.75.75.0 01-.75-.75zM8 6a1 1 0 110-2 1 1 0 010 2z"/></svg>注意</p><p><ul><li>参考文章
<a href=https://blog.csdn.net/qq_41513009/article/details/121039888 target=_blank rel="external nofollow noopener noreferrer">阅读笔记：《The Art, Science, and Engineering of Fuzzing: A Survey》<i class="fa-solid fa-external-link-alt fa-fw fa-xs ms-1 text-secondary" aria-hidden=true></i></a>
<a href=https://www.anquanke.com/post/id/263725 target=_blank rel="external nofollow noopener noreferrer">Hybrid Fuzzing Paper Summary<i class="fa-solid fa-external-link-alt fa-fw fa-xs ms-1 text-secondary" aria-hidden=true></i></a></li></ul></div><h3 id=fuzzing-的分类 class=heading-element><span>1.1 fuzzing 的分类</span>
<a href=#fuzzing-%e7%9a%84%e5%88%86%e7%b1%bb class=heading-mark><svg class="octicon octicon-link" viewBox="0 0 16 16" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5.0 114.95 4.95l-2.5 2.5a3.5 3.5.0 01-4.95.0.751.751.0 01.018-1.042.751.751.0 011.042-.018 1.998 1.998.0 002.83.0l2.5-2.5a2.002 2.002.0 00-2.83-2.83l-1.25 1.25a.751.751.0 01-1.042-.018.751.751.0 01-.018-1.042zm-4.69 9.64a1.998 1.998.0 002.83.0l1.25-1.25a.751.751.0 011.042.018.751.751.0 01.018 1.042l-1.25 1.25a3.5 3.5.0 11-4.95-4.95l2.5-2.5a3.5 3.5.0 014.95.0.751.751.0 01-.018 1.042.751.751.0 01-1.042.018 1.998 1.998.0 00-2.83.0l-2.5 2.5a1.998 1.998.0 000 2.83z"/></svg></a></h3><ul><li>根据 fuzzer 观察到的语义粒度，fuzzer 被分为黑盒 fuzzer、灰盒 fuzzer 和白盒 fuzzer。</li><li>根据 PUT 输入可分为 file, network, UI, web, kernel I/O, or threads fuzzer</li></ul><h4 id=黑盒black-boxfuzzer class=heading-element><span>1.1.1 黑盒（black-box）fuzzer</span>
<a href=#%e9%bb%91%e7%9b%92black-boxfuzzer class=heading-mark><svg class="octicon octicon-link" viewBox="0 0 16 16" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5.0 114.95 4.95l-2.5 2.5a3.5 3.5.0 01-4.95.0.751.751.0 01.018-1.042.751.751.0 011.042-.018 1.998 1.998.0 002.83.0l2.5-2.5a2.002 2.002.0 00-2.83-2.83l-1.25 1.25a.751.751.0 01-1.042-.018.751.751.0 01-.018-1.042zm-4.69 9.64a1.998 1.998.0 002.83.0l1.25-1.25a.751.751.0 011.042.018.751.751.0 01.018 1.042l-1.25 1.25a3.5 3.5.0 11-4.95-4.95l2.5-2.5a3.5 3.5.0 014.95.0.751.751.0 01-.018 1.042.751.751.0 01-1.042.018 1.998 1.998.0 00-2.83.0l-2.5 2.5a1.998 1.998.0 000 2.83z"/></svg></a></h4><ul><li>仅考虑输入、输出信息作为 fuzzer 的 knowledgement</li><li>IO-driven or data-driven</li><li>modern fuzzers：the structural informa about inputs</li></ul><h4 id=白盒white-boxfuzzer class=heading-element><span>1.1.2 白盒（white-box）fuzzer</span>
<a href=#%e7%99%bd%e7%9b%92white-boxfuzzer class=heading-mark><svg class="octicon octicon-link" viewBox="0 0 16 16" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5.0 114.95 4.95l-2.5 2.5a3.5 3.5.0 01-4.95.0.751.751.0 01.018-1.042.751.751.0 011.042-.018 1.998 1.998.0 002.83.0l2.5-2.5a2.002 2.002.0 00-2.83-2.83l-1.25 1.25a.751.751.0 01-1.042-.018.751.751.0 01-.018-1.042zm-4.69 9.64a1.998 1.998.0 002.83.0l1.25-1.25a.751.751.0 011.042.018.751.751.0 01.018 1.042l-1.25 1.25a3.5 3.5.0 11-4.95-4.95l2.5-2.5a3.5 3.5.0 014.95.0.751.751.0 01-.018 1.042.751.751.0 01-1.042.018 1.998 1.998.0 00-2.83.0l-2.5 2.5a1.998 1.998.0 000 2.83z"/></svg></a></h4><ul><li>分析 PUT 内部结构以及 PUT 执行所产生的信息，系统探索 PUT 状态空间</li><li>DSE 动态符号执行（dynamic symbolic execution，concolic testing，symbolic execution+concrete execution），简化符号执行的约束条件</li><li>污点分析（taint analysis）</li><li>开销较大（higher overhead）：动态执行+SMT solving</li></ul><h4 id=灰盒grey-boxfuzzer class=heading-element><span>1.1.3 灰盒（grey-box）fuzzer</span>
<a href=#%e7%81%b0%e7%9b%92grey-boxfuzzer class=heading-mark><svg class="octicon octicon-link" viewBox="0 0 16 16" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5.0 114.95 4.95l-2.5 2.5a3.5 3.5.0 01-4.95.0.751.751.0 01.018-1.042.751.751.0 011.042-.018 1.998 1.998.0 002.83.0l2.5-2.5a2.002 2.002.0 00-2.83-2.83l-1.25 1.25a.751.751.0 01-1.042-.018.751.751.0 01-.018-1.042zm-4.69 9.64a1.998 1.998.0 002.83.0l1.25-1.25a.751.751.0 011.042.018.751.751.0 01.018 1.042l-1.25 1.25a3.5 3.5.0 11-4.95-4.95l2.5-2.5a3.5 3.5.0 014.95.0.751.751.0 01-.018 1.042.751.751.0 01-1.042.018 1.998 1.998.0 00-2.83.0l-2.5 2.5a1.998 1.998.0 000 2.83z"/></svg></a></h4><ul><li>部分 PUT 内部结构信息以及 PUT 执行所产生的信息</li><li>不考虑完整的语义信息</li><li>lightweight static analysis or dynamic information about execution（e.g. code coverage）</li><li>approximated, imperfect information 加快速度和产生更多的测试用例</li></ul><h4 id=dynamic-symbolic-execution class=heading-element><span>1.1.4 Dynamic Symbolic Execution</span>
<a href=#dynamic-symbolic-execution class=heading-mark><svg class="octicon octicon-link" viewBox="0 0 16 16" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5.0 114.95 4.95l-2.5 2.5a3.5 3.5.0 01-4.95.0.751.751.0 01.018-1.042.751.751.0 011.042-.018 1.998 1.998.0 002.83.0l2.5-2.5a2.002 2.002.0 00-2.83-2.83l-1.25 1.25a.751.751.0 01-1.042-.018.751.751.0 01-.018-1.042zm-4.69 9.64a1.998 1.998.0 002.83.0l1.25-1.25a.751.751.0 011.042.018.751.751.0 01.018 1.042l-1.25 1.25a3.5 3.5.0 11-4.95-4.95l2.5-2.5a3.5 3.5.0 014.95.0.751.751.0 01-.018 1.042.751.751.0 01-1.042.018 1.998 1.998.0 00-2.83.0l-2.5 2.5a1.998 1.998.0 000 2.83z"/></svg></a></h4><p>经典的符号执行是指使用符号化的值作为输入运行一个程序，这些符号化的变量代表所有可能的值。当符号执行器执行 PUT 时，它会建立一个符号表达式而不是计算实际的变量。当它遇到一个条件分支指令的时候，它会分为两个 symbolic interpreter，一个代表正确分支一个代表错误分支。对每一条路径，symbolic interpreter 会为执行过程中遇到的每一条分支指令建立一个路径公式（路径断言）。如果存在一个实际的输入，能够执行目标路径，那么就说该路径公式是可满足的。可以通过求解 SMT solver 来生成一个适用于路径公式的实际输入。动态符号执行是传统的符号执行的变体，在动态符号执行过程中，符号执行和实际的执行会同时进行。因此，<strong>动态符号执行通常被称为 concolic（concrete+symbolic）测试</strong>。结合动态执行的优点是实际的执行可以减小符号约束的复杂度。</p><p>相比较于灰盒或者黑盒方法而言，动态符号执行是很慢的，这是由于它需要分析 PUT 的每一条指令并插桩。为了解决开销过大的问题，一种缩小动态符号执行范畴的通用策略被提出：让用户确定代码中不感兴趣的部分或者感兴趣的片段、交替使用 conclic testing 和灰盒 fuzzing。</p><div class="alert alert-note"><p class=alert-title><svg class="icon" viewBox="0 0 16 16" width="16" height="16"><path d="M0 8a8 8 0 1116 0A8 8 0 010 8zm8-6.5a6.5 6.5.0 100 13 6.5 6.5.0 000-13zM6.5 7.75A.75.75.0 017.25 7h1a.75.75.0 01.75.75v2.75h.25a.75.75.0 010 1.5h-2a.75.75.0 010-1.5h.25v-2h-.25a.75.75.0 01-.75-.75zM8 6a1 1 0 110-2 1 1 0 010 2z"/></svg>注意</p><p><strong>DigFuzz</strong>: 用灰盒测试确定每个分支执行概率，再使用白盒 fuzzer 对对于灰盒 fuzzing 比较 challenging 的路径进行 fuzzing
<strong>DigFuzz</strong> 提出基于蒙特卡洛的路径概率排序模型 (Monte Carlo Based Probabilistic Path Prioritization Model, $MCP^3$)，在 fuzzing 的过程中，用 seed 的 trace 构建执行路径树，用覆盖率计算每个分支的概率，路径的概率为路径上分支的概率相乘，最后基于路径的概率对路径进行排序，概率越小代表路径越难探索，将最难探索的路径优先给 concolic execution 进行探索。</p></div><p><a href=https://ieeexplore.ieee.org/abstract/document/9280412 target=_blank rel="external nofollow noopener noreferrer">Probabilistic Path Prioritization for Hybrid Fuzzing<i class="fa-solid fa-external-link-alt fa-fw fa-xs ms-1 text-secondary" aria-hidden=true></i></a>
主要翻译参考自 <a href=https://fgroove.github.io/2019/03/27/digfuzz/ target=_blank rel="external nofollow noopener noreferrer">DigFuzz<i class="fa-solid fa-external-link-alt fa-fw fa-xs ms-1 text-secondary" aria-hidden=true></i></a>。</p><h2 id=abstract class=heading-element><span>2 Abstract</span>
<a href=#abstract class=heading-mark><svg class="octicon octicon-link" viewBox="0 0 16 16" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5.0 114.95 4.95l-2.5 2.5a3.5 3.5.0 01-4.95.0.751.751.0 01.018-1.042.751.751.0 011.042-.018 1.998 1.998.0 002.83.0l2.5-2.5a2.002 2.002.0 00-2.83-2.83l-1.25 1.25a.751.751.0 01-1.042-.018.751.751.0 01-.018-1.042zm-4.69 9.64a1.998 1.998.0 002.83.0l1.25-1.25a.751.751.0 011.042.018.751.751.0 01.018 1.042l-1.25 1.25a3.5 3.5.0 11-4.95-4.95l2.5-2.5a3.5 3.5.0 014.95.0.751.751.0 01-.018 1.042.751.751.0 01-1.042.018 1.998 1.998.0 00-2.83.0l-2.5 2.5a1.998 1.998.0 000 2.83z"/></svg></a></h2><p>混合模糊测试结合了模糊测试和符号执行，是一种先进的软件漏洞检测技术。基于对模糊和符号执行本质上是互补的观察，最先进的混合模糊测试系统部署了<code>需求启动 demand launch</code>和<code>最佳切换 optimal switch</code>策略。虽然这些想法听起来很有意思，但由于过于简单的假设，我们指出了它们中的几个基本限制。</p><p>然后，我们提出了一种新颖的<code>判别式调度 discriminative dispatch</code>策略，以更好地利用符号执行的能力。我们设计了一种新的基于<code>Monte Carlo</code>的概率路径优先级模型，用于量化每条路径的难度，并优先考虑它们的符号执行。此模型将模糊测试视为随机抽样过程，根据采样信息计算每个路径的概率。最后，我们的模型<strong>优先考虑并指定最困难的路径来符号执行</strong>。</p><p>我们实现了原型系统<code>DigFuzz</code>，并使用两个有代表性的数据集评估我们的系统。结果表明，在各个主要方面，<code>DigFuzz</code>中的符号执行性能优于最先进的混合模糊测试系统。特别是，<code>DigFuzz</code>中的符号执行有助于发现更多的漏洞（12对5），并在<code>CQE</code>数据集上产生比在<code>Driller</code>中执行的更多代码覆盖（18.9％对3.8％）。</p><h2 id=introduction class=heading-element><span>3 Introduction</span>
<a href=#introduction class=heading-mark><svg class="octicon octicon-link" viewBox="0 0 16 16" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5.0 114.95 4.95l-2.5 2.5a3.5 3.5.0 01-4.95.0.751.751.0 01.018-1.042.751.751.0 011.042-.018 1.998 1.998.0 002.83.0l2.5-2.5a2.002 2.002.0 00-2.83-2.83l-1.25 1.25a.751.751.0 01-1.042-.018.751.751.0 01-.018-1.042zm-4.69 9.64a1.998 1.998.0 002.83.0l1.25-1.25a.751.751.0 011.042.018.751.751.0 01.018 1.042l-1.25 1.25a3.5 3.5.0 11-4.95-4.95l2.5-2.5a3.5 3.5.0 014.95.0.751.751.0 01-.018 1.042.751.751.0 01-1.042.018 1.998 1.998.0 00-2.83.0l-2.5 2.5a1.998 1.998.0 000 2.83z"/></svg></a></h2><p>软件漏洞被认为是对网络空间最严重的威胁之一。因此，发现一个软件中的漏洞至关重要[12]，[16]，[25]，[27]，[32]。最近，模糊测试和符号执行的组合——混合模糊测试，在漏洞发现中变得越来越流行[5]，[29]，[31]，[39]，[42]，[46]。</p><p>由于模糊测试和符号执行本质上是互补的，因此将它们结合起来可以潜在地利用它们的独特优势并减轻弱点。更具体地说，模糊测试（Fuzzing）擅长探索包含一般分支（具有大的满足值空间的分支，比如 x>100）的路径，但是不能探索包含特定分支的路径（具有非常窄的满足值空间的分支,比如 x=2）[27]。相反，符号执行能够生成具体的输入，确保程序沿着特定的执行路径执行，但它会遇到路径爆炸问题[9]。</p><p>在混合方案中，模糊测试由于高吞吐量通常承担路径探索的大多数任务，而符号执行辅助模糊测试探索低概率的路径、并且生成满足特定分支的输入。通过这种方式，可以减轻分支符号执行中的路径爆炸问题，因为符号执行仅负责探索可能阻止模糊测试的低概率路径。</p><p><strong>关键的研究问题是如何结合模糊测试和符号执行以实现最佳的整体性能</strong>。<code>Driller</code>[39]和<code>hybrid concolic testing</code>[29]采取<code>需求启动</code>策略：模糊测试首先开始，并且只有当模糊测试在一段时间内无法取得任何进展（即卡住<code>stuck</code>）时才会启动符号执行。最近的一项工作[42]提出了一种<code>最佳切换 optimal switch</code>策略：它通过模糊测试和符号执行来量化探索每条路径的成本，并选择更经济的方法来探索这条路径。</p><p>我们使用<code>DARPA CQE</code>数据集[13]<code>和LAVA-m</code>数据集[15]评估了<code>需求启动</code>和<code>最佳切换</code>策略，并发现尽管这些策略听起来很有趣，但由于不太现实或过度简化的假设，它们都没有充分发挥作用。</p><ol><li>对于<code>需求启动 demand launch</code>策略：</li></ol><ul><li>模糊器(<code>Fuzzer</code>)的卡住状态不是良好的启动符号执行指标
模糊测试正在取得进展，并不一定意味着不需要进行符号执行。模糊器仍然可以探索新代码，即使它已经被许多特定分支阻塞，而因为模糊器未处于卡住状态，因此符号执行器被迫空闲。</li><li>该策略无法识别阻止模糊测试的特定路径
一旦模糊器卡住，<code>需求启动 demand launch</code>策略就会将模糊器保留的所有种子提供给符号执行，用于探索所有错过路径。然后，这种大量错过的路径会让执符号执行不堪重负，并且可能会在很长一段时间后为特定路径生成有效的输入。到那时，模糊器可能已经生成了一个良好的输入来遍历该特定路径，从而使整个符号执行变得毫无用处。</li></ul><ol start=2><li>同样，尽管<code>最佳切换 optimal switch</code>策略旨在基于可靠的数学模型（即，具有成本的马尔可夫决策过程，简称<code>MDPC</code>）做出最优决策，但是量化每条路径的模糊测试和符号执行的成本是非常重要的。例如，为了量化特定路径的独立执行成本，<code>MDPC</code>需要收集已经很昂贵的路径约束。结果，<code>MDPC</code>的总吞吐量大大降低。此外，在量化模糊测试的成本时，<code>MDPC</code>假设所有测试用例均匀分布。这种假设过于简单，因为许多最先进的模糊测试技术[4]，[12]，[16]是自适应和进化的。最后，即使可以准确地估计模糊测试和符号执行的成本，但要将它们标准化以进行统一比较是具有挑战性的，因为这两种成本是通过具有不同度量的技术来估计的。</li></ol><p>基于这些观察，我们在构建混合模糊测试系统时争论以下设计原则：</p><ol><li>由于符号执行比模糊测试慢几个数量级，我们应该只让它解决<code>最难的问题</code>，并让模糊测试采取路径探索的多数任务</li><li>由于高吞吐量对于模糊测试至关重要，因此任何额外的分析都必须是轻量级的，以避免对模糊测试的性能产生不利影响。</li></ol><p>在本文中，我们提出了一种<code>判别式调度 discriminative dispatch</code>策略，以更好地结合模糊测试和符号执行：</p><ol><li>优先考虑路径，更好地利用符号执行的能力：以便<strong>符号执行仅用于模糊测试最难以突破的选择性路径</strong></li><li>这种<code>判别式调度</code>策略的关键是<strong>量化每条路径的难度级别的轻量级方法</strong>。先前的工作通过执行昂贵的符号执行来解决这个问题[18]，因此不适合我们的目的。</li></ol><p>特别地，我们提出了一种新的基于蒙特卡罗的概率路径优先级（$MCP^3$）模型，以有效的方式量化每个路径的难度。通过随机输入$\Rightarrow$遍历该路径的概率$\Rightarrow$量化路径的难度。我们使用蒙特卡罗方法[35]计算这个概率。核心思想是<strong>将模糊测试视为随机抽样过程，将随机执行视为整个程序空间的样本，然后根据抽样信息计算每个路径的概率</strong>。</p><p>我们已经实现了一个名为<strong>DigFuzz</strong>的原型系统。它利用流行的模糊器，<code>American Fuzzy Lop(AFL)</code>[47]作为模糊组件，并在开源符号执行引擎<code>Angr</code>之上构建了一个符号执行器[38]。我们使用来自 ARPA Cyber Grand Challenge [13]和 LAVA 数据集[15]的 CQE 评估来评估<code>DigFuzz</code>的有效性。评估结果表明，与最先进的混合系统相比，<code>DigFuzz</code>中的复杂执行对代码覆盖率的增加和发现的漏洞数量的增加做出了更大的贡献。相较于 Driller [39]，<code>DigFuzz</code>有助于发现更多的漏洞（12对5），并在 CQE 数据集上产生更多的代码覆盖率（18.9％对3.8％）。</p><p>论文贡献概述如下：</p><ul><li>我们对两种最先进的混合模糊测试策略（<code>需求启动</code>和<code>最佳切换</code>）进行独立评估，并发现以前未报告过的几个重要限制。</li><li>我们提出了一种新颖的<code>判别式调度</code>策略，作为构建混合模糊测试系统的更好方法。它遵循两个设计原则：1）<strong>让模糊测试进行路径探索的大多数任务，并且只分配最困难的路径进行符号执行; 2）路径困难的量化必须是轻量级的</strong>。为了实现这两个原则，我们设计了一个基于蒙特卡罗的概率路径优先模型。</li><li>我们实施原型系统<code>DigFuzz</code>，并使用<code>DARPA CQE</code>数据集和<code>LAVA</code>数据集评估其有效性。我们的实验表明<code>DigFuzz</code>在更多发现的漏洞和更高的代码覆盖率方面优于最先进的混合系统<code>Driller</code>和<code>MDPC</code>。</li></ul><h2 id=background-and-motivation class=heading-element><span>4 Background And Motivation</span>
<a href=#background-and-motivation class=heading-mark><svg class="octicon octicon-link" viewBox="0 0 16 16" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5.0 114.95 4.95l-2.5 2.5a3.5 3.5.0 01-4.95.0.751.751.0 01.018-1.042.751.751.0 011.042-.018 1.998 1.998.0 002.83.0l2.5-2.5a2.002 2.002.0 00-2.83-2.83l-1.25 1.25a.751.751.0 01-1.042-.018.751.751.0 01-.018-1.042zm-4.69 9.64a1.998 1.998.0 002.83.0l1.25-1.25a.751.751.0 011.042.018.751.751.0 01.018 1.042l-1.25 1.25a3.5 3.5.0 11-4.95-4.95l2.5-2.5a3.5 3.5.0 014.95.0.751.751.0 01-.018 1.042.751.751.0 01-1.042.018 1.998 1.998.0 00-2.83.0l-2.5 2.5a1.998 1.998.0 000 2.83z"/></svg></a></h2><p>Fuzzing [30]和concoic execution [9]是软件测试和漏洞检测的两种代表性技术。 由于观察到模糊和执行的执行在本质上可以相互补充，已经提出了一系列技术[5]，[29]，[31]，[39]，[42]将它们组合在一起并创建混合模糊系统。通常，这些混合模糊测试系统分为两类：“需求启动”和“最佳切换”。</p><h3 id=demand-launch class=heading-element><span>4.1 Demand Launch</span>
<a href=#demand-launch class=heading-mark><svg class="octicon octicon-link" viewBox="0 0 16 16" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5.0 114.95 4.95l-2.5 2.5a3.5 3.5.0 01-4.95.0.751.751.0 01.018-1.042.751.751.0 011.042-.018 1.998 1.998.0 002.83.0l2.5-2.5a2.002 2.002.0 00-2.83-2.83l-1.25 1.25a.751.751.0 01-1.042-.018.751.751.0 01-.018-1.042zm-4.69 9.64a1.998 1.998.0 002.83.0l1.25-1.25a.751.751.0 011.042.018.751.751.0 01.018 1.042l-1.25 1.25a3.5 3.5.0 11-4.95-4.95l2.5-2.5a3.5 3.5.0 014.95.0.751.751.0 01-.018 1.042.751.751.0 01-1.042.018 1.998 1.998.0 00-2.83.0l-2.5 2.5a1.998 1.998.0 000 2.83z"/></svg></a></h3><p>最先进的混合方案，如Driller [39]和混合动力系统测试[29]部署了“需求启动”战略。在Driller [39]中，由于模糊器在一段时间内无法取得任何进展，因此该模板执行器仍处于空闲状态。然后，它依次处理来自模糊器的所有保留输入，以生成可能有助于模糊器的输入，并进一步导致新的代码覆盖。类似地，混合分析测试[29]通过混合测试获得了对程序状态空间的深入和广泛的探索。它通过利用随机测试的能力快速到达程序状态，然后通过执行执行彻底探索邻居状态。</p><p>在一个问题上，必须有两个假设才能使“需求启动”战略按预期发挥作用：</p><ol><li>非卡住状态的模糊器意味着不需要执行。只有当模糊器卡住时，混合系统才应该开始执行。</li><li>卡住状态表明模糊器在可接受的时间内无法在发现新的代码覆盖范围方面取得任何进展。此外，具有执行力的执行能够找到并解决阻塞模糊器的难以解决的条件检查，以便模糊测试可以继续发现新的覆盖范围。</li></ol><h4 id=观察 class=heading-element><span>4.1.1 观察</span>
<a href=#%e8%a7%82%e5%af%9f class=heading-mark><svg class="octicon octicon-link" viewBox="0 0 16 16" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5.0 114.95 4.95l-2.5 2.5a3.5 3.5.0 01-4.95.0.751.751.0 01.018-1.042.751.751.0 011.042-.018 1.998 1.998.0 002.83.0l2.5-2.5a2.002 2.002.0 00-2.83-2.83l-1.25 1.25a.751.751.0 01-1.042-.018.751.751.0 01-.018-1.042zm-4.69 9.64a1.998 1.998.0 002.83.0l1.25-1.25a.751.751.0 011.042.018.751.751.0 01.018 1.042l-1.25 1.25a3.5 3.5.0 11-4.95-4.95l2.5-2.5a3.5 3.5.0 014.95.0.751.751.0 01-.018 1.042.751.751.0 01-1.042.018 1.998 1.998.0 00-2.83.0l-2.5 2.5a1.998 1.998.0 000 2.83z"/></svg></a></h4><p>为了评估<code>需求启动</code>战略的表现，我们仔细研究了 Driller 如何在 DARPA Cyber Grand Challenge（CGC）的12个小时中工作12小时，并找到五个有趣且令人惊讶的事实。</p><ol><li><em>调用 concolic 执行的百分比较低</em>。Driller 仅在118个二进制文件中的49个中调用了 concoic 执行，这意味着模糊器只会卡在这49个二进制文件上。这一事实与 Driller [40]的论文中报道的数字（42）相当。</li><li><em>卡住的时间段较少</em>。对于<code>事实1</code>中的49个二进制文件，我们统计计算卡住时间段，卡住时间段的分布如图1所示。我们可以观察到超过85％的卡住时间段低于100秒。<figure><a class=lightgallery href="https://cdn.haoyep.com/gh/leegical/Blog_img/md_img202312101455060.png?size=large" data-thumbnail="https://cdn.haoyep.com/gh/leegical/Blog_img/md_img202312101455060.png?size=small" data-sub-html="<h2> </h2><p>图1. 停滞状态持续时间的累积分布</p>"><img loading=lazy src=https://cdn.haoyep.com/gh/leegical/Blog_img/md_img202312101455060.png alt="图1. 停滞状态持续时间的累积分布" srcset="https://cdn.haoyep.com/gh/leegical/Blog_img/md_img202312101455060.png?size=small, https://cdn.haoyep.com/gh/leegical/Blog_img/md_img202312101455060.png?size=medium 1.5x, https://cdn.haoyep.com/gh/leegical/Blog_img/md_img202312101455060.png?size=large 2x" data-title="图1. 停滞状态持续时间的累积分布" style="background:url(/images/loading.min.svg)no-repeat 50%" onload='this.title=this.dataset.title;for(const e of["style","data-title","onerror","onload"])this.removeAttribute(e);this.dataset.lazyloaded=""' onerror='this.title=this.dataset.title;for(const e of["style","data-title","onerror","onload"])this.removeAttribute(e)'></a><figcaption class=image-caption>图1. 停滞状态持续时间的累积分布</figcaption></figure></li><li><em>巨大的吞吐量差距</em>。表1 中的执行时间表明，模糊测试的吞吐量比 concolic 执行的吞吐量高出几个数量级。因此，一个实际的设计应该只选择很少的输入来执行，而不是“需求启动”策略，后者将模糊测试保留的所有输入都提供给 concolic 执行器。平均而言，为一个具体的输入完成动态符号执行需要1654秒。<figure><a class=lightgallery href="https://cdn.haoyep.com/gh/leegical/Blog_img/md_img202312101456025.png?size=large" data-thumbnail="https://cdn.haoyep.com/gh/leegical/Blog_img/md_img202312101456025.png?size=small" data-sub-html="<h2> </h2><p>表1 执行时间比较</p>"><img loading=lazy src=https://cdn.haoyep.com/gh/leegical/Blog_img/md_img202312101456025.png alt="表1 执行时间比较" srcset="https://cdn.haoyep.com/gh/leegical/Blog_img/md_img202312101456025.png?size=small, https://cdn.haoyep.com/gh/leegical/Blog_img/md_img202312101456025.png?size=medium 1.5x, https://cdn.haoyep.com/gh/leegical/Blog_img/md_img202312101456025.png?size=large 2x" data-title="表1 执行时间比较" style="background:url(/images/loading.min.svg)no-repeat 50%" onload='this.title=this.dataset.title;for(const e of["style","data-title","onerror","onload"])this.removeAttribute(e);this.dataset.lazyloaded=""' onerror='this.title=this.dataset.title;for(const e of["style","data-title","onerror","onload"])this.removeAttribute(e)'></a><figcaption class=image-caption>表1 执行时间比较</figcaption></figure></li><li><em>实用性低</em>。由于存在如此巨大的吞吐量差距，在实践中，对于“需求启动”策略，符号执行对模糊测试的帮助很有限。图2显示了对 CQE 二进制文件进行符号执行（angr）处理的输入数量和模糊测试器保留的输入数量（23915个中的1709个）。对于12个实际程序，表2显示 QSYM 处理了795个输入，而模糊测试器保留的输入总数为15269个。平均而言，在12小时的测试中，只有模糊测试器保留的输入中的6.3%被符号执行器处理。<figure><a class=lightgallery href="https://cdn.haoyep.com/gh/leegical/Blog_img/md_img202312101454643.png?size=large" data-thumbnail="https://cdn.haoyep.com/gh/leegical/Blog_img/md_img202312101454643.png?size=small" data-sub-html="<h2> </h2><p>图2. 模糊器保留的输入数和 concolic 执行处理的输入数。</p>"><img loading=lazy src=https://cdn.haoyep.com/gh/leegical/Blog_img/md_img202312101454643.png alt="图2. 模糊器保留的输入数和 concolic 执行处理的输入数。" srcset="https://cdn.haoyep.com/gh/leegical/Blog_img/md_img202312101454643.png?size=small, https://cdn.haoyep.com/gh/leegical/Blog_img/md_img202312101454643.png?size=medium 1.5x, https://cdn.haoyep.com/gh/leegical/Blog_img/md_img202312101454643.png?size=large 2x" data-title="图2. 模糊器保留的输入数和 concolic 执行处理的输入数。" style="background:url(/images/loading.min.svg)no-repeat 50%" onload='this.title=this.dataset.title;for(const e of["style","data-title","onerror","onload"])this.removeAttribute(e);this.dataset.lazyloaded=""' onerror='this.title=this.dataset.title;for(const e of["style","data-title","onerror","onload"])this.removeAttribute(e)'></a><figcaption class=image-caption>图2. 模糊器保留的输入数和 concolic 执行处理的输入数。</figcaption></figure></li></ol><p><figure><a class=lightgallery href="https://cdn.haoyep.com/gh/leegical/Blog_img/md_img202312101503685.png?size=large" data-thumbnail="https://cdn.haoyep.com/gh/leegical/Blog_img/md_img202312101503685.png?size=small" data-sub-html="<h2> </h2><p>表2 输入由 Fuzzer 保留并由 QSYM 处理</p>"><img loading=lazy src=https://cdn.haoyep.com/gh/leegical/Blog_img/md_img202312101503685.png alt="表2 输入由 Fuzzer 保留并由 QSYM 处理" srcset="https://cdn.haoyep.com/gh/leegical/Blog_img/md_img202312101503685.png?size=small, https://cdn.haoyep.com/gh/leegical/Blog_img/md_img202312101503685.png?size=medium 1.5x, https://cdn.haoyep.com/gh/leegical/Blog_img/md_img202312101503685.png?size=large 2x" data-title="表2 输入由 Fuzzer 保留并由 QSYM 处理" style="background:url(/images/loading.min.svg)no-repeat 50%" onload='this.title=this.dataset.title;for(const e of["style","data-title","onerror","onload"])this.removeAttribute(e);this.dataset.lazyloaded=""' onerror='this.title=this.dataset.title;for(const e of["style","data-title","onerror","onload"])this.removeAttribute(e)'></a><figcaption class=image-caption>表2 输入由 Fuzzer 保留并由 QSYM 处理</figcaption></figure></p><ol start=5><li><em>对代码覆盖率的贡献很小</em>。在 12 小时的测试结束时，“需求启动”策略在 49 个 CQE 二进制文件上调用了 concolic 执行，并完成了 1709 次运行。更详细的调查显示，总共只有 51 个由 concolic 执行生成的输入是通过模糊测试导入的，并且 concolic 执行只能通过生成至少一个导致新代码覆盖率的输入来帮助对 13 个二进制文件进行模糊测试。</li></ol><h4 id=局限性 class=heading-element><span>4.1.2 局限性</span>
<a href=#%e5%b1%80%e9%99%90%e6%80%a7 class=heading-mark><svg class="octicon octicon-link" viewBox="0 0 16 16" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5.0 114.95 4.95l-2.5 2.5a3.5 3.5.0 01-4.95.0.751.751.0 01.018-1.042.751.751.0 011.042-.018 1.998 1.998.0 002.83.0l2.5-2.5a2.002 2.002.0 00-2.83-2.83l-1.25 1.25a.751.751.0 01-1.042-.018.751.751.0 01-.018-1.042zm-4.69 9.64a1.998 1.998.0 002.83.0l1.25-1.25a.751.751.0 011.042.018.751.751.0 01.018 1.042l-1.25 1.25a3.5 3.5.0 11-4.95-4.95l2.5-2.5a3.5 3.5.0 014.95.0.751.751.0 01-.018 1.042.751.751.0 01-1.042.018 1.998 1.998.0 00-2.83.0l-2.5 2.5a1.998 1.998.0 000 2.83z"/></svg></a></h4><p>上述结果表明<code>需求启动</code>策略的两个主要局限。</p><p>首先，<strong>模糊器的卡住状态不是判断是否需要执行模板的好指标</strong>。根据事实1，模糊器仅停留在49个二进制文件上，这意味着其他77个二进制文件永远不会启动模仿执行。对这77个二进制文件的源代码进行手动调查表明，它们都包含可以阻止模糊测试的特定分支。进一步结合事实2，我们可以看到处于卡住状态的模糊器并不一定意味着它实际上需要执行，因为大多数卡住状态非常短（85％的卡住状态不到100秒）。这些事实打破了上述假设1。</p><p>其次，<strong>“需求启动”策略无法识别阻止模糊测试的特定路径，从而导致非常低效的执行</strong>。一方面，平均执行平均需要1654秒来处理一个输入（事实3）。另一方面，模糊器通常比常规执行可以保留更多的输入（事实4）。结果，对应于阻止模糊测试的特定分支的输入（即，可能导致执行到目标位置的输入）仅具有非常小的机会被通过结构执行来拾取和处理。因此，上述假设2在实践中并不真正成立。事实5可以进一步证实这一结论，尽管它是在49个二进制文件上发布的，但是对于仅仅13个二进制文件的执行可以帮助模糊测试。此外，在1709次符号执行之后，模糊执行器仅导入了51个来自符号执行的输入，表明由符号执行而产生的输入质量非常低。</p><h3 id=optimal-switch class=heading-element><span>4.2 Optimal Switch</span>
<a href=#optimal-switch class=heading-mark><svg class="octicon octicon-link" viewBox="0 0 16 16" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5.0 114.95 4.95l-2.5 2.5a3.5 3.5.0 01-4.95.0.751.751.0 01.018-1.042.751.751.0 011.042-.018 1.998 1.998.0 002.83.0l2.5-2.5a2.002 2.002.0 00-2.83-2.83l-1.25 1.25a.751.751.0 01-1.042-.018.751.751.0 01-.018-1.042zm-4.69 9.64a1.998 1.998.0 002.83.0l1.25-1.25a.751.751.0 011.042.018.751.751.0 01.018 1.042l-1.25 1.25a3.5 3.5.0 11-4.95-4.95l2.5-2.5a3.5 3.5.0 014.95.0.751.751.0 01-.018 1.042.751.751.0 01-1.042.018 1.998 1.998.0 00-2.83.0l-2.5 2.5a1.998 1.998.0 000 2.83z"/></svg></a></h3><p>“最佳切换”策略旨在基于数学模型（即，具有成本的马尔可夫决策过程，简称<code>MDPC</code>）对使用哪种方法来探索给定的执行路径做出最佳决策。为了获得最佳性能，MDPC 始终选择成本较低的方法来探索每条路径。为了使这一战略运作良好，必须遵循以下假设：</p><ol><li>可以准确地估计通过模糊和经验执行来探索路径的成本</li><li>成本估算的开销可以忽略不计</li><li>用于做出最优决策的算法是轻量级的</li></ol><h4 id=观察-1 class=heading-element><span>4.2.1 观察</span>
<a href=#%e8%a7%82%e5%af%9f-1 class=heading-mark><svg class="octicon octicon-link" viewBox="0 0 16 16" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5.0 114.95 4.95l-2.5 2.5a3.5 3.5.0 01-4.95.0.751.751.0 01.018-1.042.751.751.0 011.042-.018 1.998 1.998.0 002.83.0l2.5-2.5a2.002 2.002.0 00-2.83-2.83l-1.25 1.25a.751.751.0 01-1.042-.018.751.751.0 01-.018-1.042zm-4.69 9.64a1.998 1.998.0 002.83.0l1.25-1.25a.751.751.0 011.042.018.751.751.0 01.018 1.042l-1.25 1.25a3.5 3.5.0 11-4.95-4.95l2.5-2.5a3.5 3.5.0 014.95.0.751.751.0 01-.018 1.042.751.751.0 01-1.042.018 1.998 1.998.0 00-2.83.0l-2.5 2.5a1.998 1.998.0 000 2.83z"/></svg></a></h4><p>为了评估<code>最佳切换</code>的性能，我们评估了 MDPC 如何在 CQE 数据集中对118个二进制文件工作12小时，并有3个有趣的观察结果。</p><ol><li><p><em>Heavyweight Estimation</em>。表1 显示了模糊测试、MDPC、符号执行（angr、QSYM）中的最佳决策之间的吞吐量差距。可以观察到使用 MDPC 计算概率的成本很高，是模糊测试的大几千倍。<figure><a class=lightgallery href="https://cdn.haoyep.com/gh/leegical/Blog_img/md_img202312101456025.png?size=large" data-thumbnail="https://cdn.haoyep.com/gh/leegical/Blog_img/md_img202312101456025.png?size=small" data-sub-html="<h2> </h2><p>表1 执行时间比较</p>"><img loading=lazy src=https://cdn.haoyep.com/gh/leegical/Blog_img/md_img202312101456025.png alt="表1 执行时间比较" srcset="https://cdn.haoyep.com/gh/leegical/Blog_img/md_img202312101456025.png?size=small, https://cdn.haoyep.com/gh/leegical/Blog_img/md_img202312101456025.png?size=medium 1.5x, https://cdn.haoyep.com/gh/leegical/Blog_img/md_img202312101456025.png?size=large 2x" data-title="表1 执行时间比较" style="background:url(/images/loading.min.svg)no-repeat 50%" onload='this.title=this.dataset.title;for(const e of["style","data-title","onerror","onload"])this.removeAttribute(e);this.dataset.lazyloaded=""' onerror='this.title=this.dataset.title;for(const e of["style","data-title","onerror","onload"])this.removeAttribute(e)'></a><figcaption class=image-caption>表1 执行时间比较</figcaption></figure></p></li><li><p><em>吞吐量降低</em>。由于 MDPC 在探索每条路径之前做出最佳决策，因此整体分析吞吐量显着降低，从纯模糊测试中每秒执行417次到 MDPC 中每秒执行2.6次。由于吞吐量减少的负面影响，下图显示了由 AFL 维护的位图大小，这是代码覆盖的近似。可以观察到，<code>optimal concolic testing</code>发现的代码覆盖较少，而不如纯模糊测试。</p></li><li><p><em>估计不准确</em>。由于吞吐量降低的影响，MDPC 仅在29个二进制文件中发现漏洞，而纯模糊测试可以发现67个二进制文件中的漏洞。<figure><a class=lightgallery href="https://cdn.haoyep.com/gh/leegical/Blog_img/md_img202312101511673.png?size=large" data-thumbnail="https://cdn.haoyep.com/gh/leegical/Blog_img/md_img202312101511673.png?size=small" data-sub-html="<h2> </h2><p>Fuzing和MDPC的代码覆盖率比较</p>"><img loading=lazy src=https://cdn.haoyep.com/gh/leegical/Blog_img/md_img202312101511673.png alt=Fuzing和MDPC的代码覆盖率比较 srcset="https://cdn.haoyep.com/gh/leegical/Blog_img/md_img202312101511673.png?size=small, https://cdn.haoyep.com/gh/leegical/Blog_img/md_img202312101511673.png?size=medium 1.5x, https://cdn.haoyep.com/gh/leegical/Blog_img/md_img202312101511673.png?size=large 2x" data-title=Fuzing和MDPC的代码覆盖率比较 style="background:url(/images/loading.min.svg)no-repeat 50%" onload='this.title=this.dataset.title;for(const e of["style","data-title","onerror","onload"])this.removeAttribute(e);this.dataset.lazyloaded=""' onerror='this.title=this.dataset.title;for(const e of["style","data-title","onerror","onload"])this.removeAttribute(e)'></a><figcaption class=image-caption>Fuzing和MDPC的代码覆盖率比较</figcaption></figure>由于 MDPC 在探索每条路径之前做出了最佳决策，昂贵的最优决策都会带走模糊测量的高吞吐量。作为优化，使模糊测试和最优决策工作并行进行，而不是像在原始系统中那样按顺序运行，并构建并发 MDPC。使用相同的数据集对其进行评估，并得出以下观察结果，我们有另一个观察。</p></li><li><p>在模糊测试开始后的几秒钟内，几乎所有遗漏的路径都决定通过 concolic 执行进行探索。通过检查覆盖率统计，我们观察到模糊器能够在几秒钟内生成数百个测试用例，这导致基于 MDPC 算法的 Fuzzing 搜索遗漏路径的代价很高。相反，即使我们为每个路径约束分配最高的求解成本(如定义[42]所示的50)，也可以降低执行成本。</p></li></ol><h4 id=限制 class=heading-element><span>4.2.2 限制</span>
<a href=#%e9%99%90%e5%88%b6 class=heading-mark><svg class="octicon octicon-link" viewBox="0 0 16 16" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5.0 114.95 4.95l-2.5 2.5a3.5 3.5.0 01-4.95.0.751.751.0 01.018-1.042.751.751.0 011.042-.018 1.998 1.998.0 002.83.0l2.5-2.5a2.002 2.002.0 00-2.83-2.83l-1.25 1.25a.751.751.0 01-1.042-.018.751.751.0 01-.018-1.042zm-4.69 9.64a1.998 1.998.0 002.83.0l1.25-1.25a.751.751.0 011.042.018.751.751.0 01.018 1.042l-1.25 1.25a3.5 3.5.0 11-4.95-4.95l2.5-2.5a3.5 3.5.0 014.95.0.751.751.0 01-.018 1.042.751.751.0 01-1.042.018 1.998 1.998.0 00-2.83.0l-2.5 2.5a1.998 1.998.0 000 2.83z"/></svg></a></h4><p>上述观察结果表明，<code>最佳切换</code>策略的关键限制是估计通过模糊测试和符号执行来探索路径的成本是重量级且不准确的，这掩盖了制定最优解决方案的好处。</p><p>首先，估计 concolic 执行的成本依赖于收集路径约束并确定这些约束的解决成本。由于收集路径约束需要将程序语句转换为符号表达式，因此这种解释也是重量级的，特别是对于具有长路径的程序。此外，MDPC 设计了一种贪婪算法以实现最佳决策。该算法依赖于路径敏感的程序分析。对于具有大状态的程序，路径敏感分析也是重量级的。</p><p>其次，准确估计通过模糊测试和符号执行探索给定路径的成本是非常重要的。MDPC 根据路径约束的复杂性估计求解代价，并根据覆盖统计估计随机测试的成本。这些估计涉及模糊测试的运行时吞吐量、约束求解器以及符号执行引擎的性能，它们本质上是不同的程序分析技术。因此，定义一个统一的衡量标准来评估不同技术的成本是具有挑战性的。</p><h2 id=probabilistic-path-prioritization-guided-by-monte-carlo class=heading-element><span>5 PROBABILISTIC PATH PRIORITIZATION GUIDED BY MONTE-CARLO</span>
<a href=#probabilistic-path-prioritization-guided-by-monte-carlo class=heading-mark><svg class="octicon octicon-link" viewBox="0 0 16 16" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5.0 114.95 4.95l-2.5 2.5a3.5 3.5.0 01-4.95.0.751.751.0 01.018-1.042.751.751.0 011.042-.018 1.998 1.998.0 002.83.0l2.5-2.5a2.002 2.002.0 00-2.83-2.83l-1.25 1.25a.751.751.0 01-1.042-.018.751.751.0 01-.018-1.042zm-4.69 9.64a1.998 1.998.0 002.83.0l1.25-1.25a.751.751.0 011.042.018.751.751.0 01.018 1.042l-1.25 1.25a3.5 3.5.0 11-4.95-4.95l2.5-2.5a3.5 3.5.0 014.95.0.751.751.0 01-.018 1.042.751.751.0 01-1.042.018 1.998 1.998.0 00-2.83.0l-2.5 2.5a1.998 1.998.0 000 2.83z"/></svg></a></h2><p>为了解决当前混合模糊测试系统的上述局限性，我们提出了一种新颖的<code>判别调度</code>策略，以更好地结合模糊和执行。</p><h3 id=key-challenge class=heading-element><span>5.1 Key Challenge</span>
<a href=#key-challenge class=heading-mark><svg class="octicon octicon-link" viewBox="0 0 16 16" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5.0 114.95 4.95l-2.5 2.5a3.5 3.5.0 01-4.95.0.751.751.0 01.018-1.042.751.751.0 011.042-.018 1.998 1.998.0 002.83.0l2.5-2.5a2.002 2.002.0 00-2.83-2.83l-1.25 1.25a.751.751.0 01-1.042-.018.751.751.0 01-.018-1.042zm-4.69 9.64a1.998 1.998.0 002.83.0l1.25-1.25a.751.751.0 011.042.018.751.751.0 01.018 1.042l-1.25 1.25a3.5 3.5.0 11-4.95-4.95l2.5-2.5a3.5 3.5.0 014.95.0.751.751.0 01-.018 1.042.751.751.0 01-1.042.018 1.998 1.998.0 00-2.83.0l-2.5 2.5a1.998 1.998.0 000 2.83z"/></svg></a></h3><p>如上所述，我们策略的关键挑战是<strong>以轻量级方式量化模糊器遍历路径的难度</strong>。</p><blockquote><p>有一些解决方案可以使用昂贵的程序分析来量化路径的难度，例如值分析[45]和概率符号执行[5]。然而，这些技术并没有解决我们的问题：如果我们已经执行了重量级分析来量化一条路径的难度，我们还不如只解决路径约束并生成一个输入来遍历这条路径。</p><p>最近的一项研究[42]提出了一种理论框架，用于优化的结构测试。它定义了基于程序路径概率和约束求解成本的最优策略，然后将问题简化为带有成本的马尔可夫决策过程（简称 MDPC）。本研究与我们的工作有着相似的问题范围。然而，马尔可夫决策过程本身对于具有大状态空间的程序来说是重量级的。此外，模糊测试和符号执行的成本对于评估和标准化以进行比较是具有挑战性的。</p></blockquote><h3 id=monte-carlo-based-probabilistic-path-prioritization-model class=heading-element><span>5.2 Monte Carlo Based Probabilistic Path Prioritization Model</span>
<a href=#monte-carlo-based-probabilistic-path-prioritization-model class=heading-mark><svg class="octicon octicon-link" viewBox="0 0 16 16" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5.0 114.95 4.95l-2.5 2.5a3.5 3.5.0 01-4.95.0.751.751.0 01.018-1.042.751.751.0 011.042-.018 1.998 1.998.0 002.83.0l2.5-2.5a2.002 2.002.0 00-2.83-2.83l-1.25 1.25a.751.751.0 01-1.042-.018.751.751.0 01-.018-1.042zm-4.69 9.64a1.998 1.998.0 002.83.0l1.25-1.25a.751.751.0 011.042.018.751.751.0 01.018 1.042l-1.25 1.25a3.5 3.5.0 11-4.95-4.95l2.5-2.5a3.5 3.5.0 014.95.0.751.751.0 01-.018 1.042.751.751.0 01-1.042.018 1.998 1.998.0 00-2.83.0l-2.5 2.5a1.998 1.998.0 000 2.83z"/></svg></a></h3><p>在这项研究中，我们提出了一种新的基于<code>Monte Carlo</code>的概率路径优先级模型（简称 $MCP^3$）来应对这些挑战。为了轻量化，我们的模型应用<code>Monte Carlo</code>方法来计算通过模糊测试探索路径的概率。要使蒙特卡罗方法有效运作，需要满足两个要求：</p><ol><li>对搜索空间的抽样必须是随机的;</li><li>需要大量随机抽样才能使估计具有统计意义。</li></ol><p>由于 fuzzer 随机生成用于测试程序的输入，我们的见解是将这些输入的执行视为整个程序状态空间的随机样本，因此满足第一个要求。此外，由于模糊测试具有非常高的吞吐量，因此也可以满足第二个要求。因此，通过将模糊测试作为抽样过程，我们可以通过覆盖统计以轻量级方式统计估计概率。</p><p>根据蒙特卡罗方法，我们可以通过统计计算遍历此路径的执行与所有执行的比率来简单地估计路径的概率。然而，这种直观的方法并不实用，因为保持路径覆盖是一项具有挑战性和重要性的任务。考虑到这一点，大多数当前的模糊测试技术采用了轻量级覆盖度量，例如块覆盖和分支覆盖。对于这一挑战，我们将执行路径视为连续分支的马尔可夫链[4]。然后，可以基于路径内所有分支的概率来计算路径的概率。</p><h4 id=probability-for-each-branch class=heading-element><span>5.2.1 Probability for each branch</span>
<a href=#probability-for-each-branch class=heading-mark><svg class="octicon octicon-link" viewBox="0 0 16 16" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5.0 114.95 4.95l-2.5 2.5a3.5 3.5.0 01-4.95.0.751.751.0 01.018-1.042.751.751.0 011.042-.018 1.998 1.998.0 002.83.0l2.5-2.5a2.002 2.002.0 00-2.83-2.83l-1.25 1.25a.751.751.0 01-1.042-.018.751.751.0 01-.018-1.042zm-4.69 9.64a1.998 1.998.0 002.83.0l1.25-1.25a.751.751.0 011.042.018.751.751.0 01.018 1.042l-1.25 1.25a3.5 3.5.0 11-4.95-4.95l2.5-2.5a3.5 3.5.0 014.95.0.751.751.0 01-.018 1.042.751.751.0 01-1.042.018 1.998 1.998.0 00-2.83.0l-2.5 2.5a1.998 1.998.0 000 2.83z"/></svg></a></h4><p>量化了模糊测试器通过条件检查并探索分支的难度。方程式1展示了$MCP^3$如何计算分支的概率。
\begin{equation*} P\left(br_i\right) = \left\lbrace \begin{array}{lr}\frac{cov \left(br_i \right)}{cov \left(br_i \right) + cov \left(br_j \right)}, & cov \left(br_i \right)\ne 0 \\
\frac{3} {{cov \left(br_j \right)}} , & cov \left(br_i \right) = 0 \end{array} \right. \tag{1} \end{equation*}</p><p>在<code>方程1</code>中，$b_{ri}$ 和 $b_{rj}$ 是共享相同前继块的两个分支，$cov(b_{ri})$ 和 $cov(b_{rj})$ 分别指的是 $b_{ri}$ 和 $b_{rj}$ 的覆盖统计，表示模糊测试器的样本覆盖了 $b_{ri}$ 和 $b_{rj}$ 的次数。</p><ul><li>当 $b_{ri}$ 已经被模糊测试器探索过（$cov(b_{ri})$ 非零时），$b_{ri}$ 的概率可以通过将 $b_{ri}$ 的覆盖统计除以 $b_{ri}$ 和 $b_{rj}$ 的总覆盖统计来计算。</li><li>当 $b_{ri}$ 之前未被模糊测试器探索过（$cov(b_{ri})$ 为零），我们采用统计学中的三比规则[43]来计算 $b_{ri}$ 的概率。三比规则表明，如果某一事件在包含 n 个主体的样本中未发生，则从 0 到 3/n 的区间是该事件在总体中发生率的95%置信区间。当 n 大于$30$时，这是对来自更敏感测试的结果的一个很好的近似。遵循这个规则，如果 $cov(b_{rj})$ 大于$30$，则 $b_{ri}$ 的概率变为 $3/cov(b_{rj})$。如果 $cov(b_{rj})$ 小于$30$，则该概率在统计上没有意义。换句话说，在覆盖统计大于$30$之前，我们将不计算概率。</li></ul><h4 id=probability-for-each-path class=heading-element><span>5.2.2 Probability for each path</span>
<a href=#probability-for-each-path class=heading-mark><svg class="octicon octicon-link" viewBox="0 0 16 16" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5.0 114.95 4.95l-2.5 2.5a3.5 3.5.0 01-4.95.0.751.751.0 01.018-1.042.751.751.0 011.042-.018 1.998 1.998.0 002.83.0l2.5-2.5a2.002 2.002.0 00-2.83-2.83l-1.25 1.25a.751.751.0 01-1.042-.018.751.751.0 01-.018-1.042zm-4.69 9.64a1.998 1.998.0 002.83.0l1.25-1.25a.751.751.0 011.042.018.751.751.0 01.018 1.042l-1.25 1.25a3.5 3.5.0 11-4.95-4.95l2.5-2.5a3.5 3.5.0 014.95.0.751.751.0 01-.018 1.042.751.751.0 01-1.042.018 1.998 1.998.0 00-2.83.0l-2.5 2.5a1.998 1.998.0 000 2.83z"/></svg></a></h4><p>为了计算路径的概率，我们应用马尔可夫链模型[19]，将路径视为相继分支之间的连续转换[4]。模糊测试器探索路径的概率计算如<code>方程2</code>所示。
\begin{equation*} P \left(path_j \right) = \prod \lbrace P\left(br_i \right) | br_i \in path_j \rbrace . \tag{2} \end{equation*}</p><p>在方程2中，$path_j$ 代表一个路径，$b_{ri}$ 表示路径覆盖的分支，$P(b_{ri})$ 表示 $b_{ri}$ 的概率。路径 $path_j$ 的概率，即 $P(path_j)$，通过将沿路径的所有分支的概率相乘来计算。</p><h3 id=mcp3based-execution-tree class=heading-element><span>5.3 $MCP^3$ based Execution Tree</span>
<a href=#mcp3based-execution-tree class=heading-mark><svg class="octicon octicon-link" viewBox="0 0 16 16" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5.0 114.95 4.95l-2.5 2.5a3.5 3.5.0 01-4.95.0.751.751.0 01.018-1.042.751.751.0 011.042-.018 1.998 1.998.0 002.83.0l2.5-2.5a2.002 2.002.0 00-2.83-2.83l-1.25 1.25a.751.751.0 01-1.042-.018.751.751.0 01-.018-1.042zm-4.69 9.64a1.998 1.998.0 002.83.0l1.25-1.25a.751.751.0 011.042.018.751.751.0 01.018 1.042l-1.25 1.25a3.5 3.5.0 11-4.95-4.95l2.5-2.5a3.5 3.5.0 014.95.0.751.751.0 01-.018 1.042.751.751.0 01-1.042.018 1.998 1.998.0 00-2.83.0l-2.5 2.5a1.998 1.998.0 000 2.83z"/></svg></a></h3><p>在我们的<code>判别式调度</code>策略中，关键思想是从模糊测试执行的运行时信息推断并优先考虑符号执行的路径。为此，我们构建并维护一个基于$MCP^3$的执行树。</p><h4 id=定义1 class=heading-element><span>5.3.1 <strong>定义1</strong></span>
<a href=#%e5%ae%9a%e4%b9%891 class=heading-mark><svg class="octicon octicon-link" viewBox="0 0 16 16" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5.0 114.95 4.95l-2.5 2.5a3.5 3.5.0 01-4.95.0.751.751.0 01.018-1.042.751.751.0 011.042-.018 1.998 1.998.0 002.83.0l2.5-2.5a2.002 2.002.0 00-2.83-2.83l-1.25 1.25a.751.751.0 01-1.042-.018.751.751.0 01-.018-1.042zm-4.69 9.64a1.998 1.998.0 002.83.0l1.25-1.25a.751.751.0 011.042.018.751.751.0 01.018 1.042l-1.25 1.25a3.5 3.5.0 11-4.95-4.95l2.5-2.5a3.5 3.5.0 014.95.0.751.751.0 01-.018 1.042.751.751.0 01-1.042.018 1.998 1.998.0 00-2.83.0l-2.5 2.5a1.998 1.998.0 000 2.83z"/></svg></a></h4><p>基于$MCP^3$的执行树是是一个有向树 $T = (V, E, \alpha)$，其中：</p><ul><li>顶点集合 $V$ 中的每个元素 $v$ 对应于程序执行期间的程序轨迹中的一个唯一基本块；</li><li>边集合 $E⊆V \times V$ 中的每个元素$e$对应于两个顶点 $v$ 和 $w$ 之间的控制流依赖性，其中$v,w \in V$。如果一个顶点包含条件检查，则可以有两个输出边；</li><li>标记函数$\alpha: E \to \Sigma$将边与概率标签相关联，其中每个标签表示模糊测试器通过该分支的概率。</li></ul><h2 id=design-and-implementation class=heading-element><span>6 Design and Implementation</span>
<a href=#design-and-implementation class=heading-mark><svg class="octicon octicon-link" viewBox="0 0 16 16" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5.0 114.95 4.95l-2.5 2.5a3.5 3.5.0 01-4.95.0.751.751.0 01.018-1.042.751.751.0 011.042-.018 1.998 1.998.0 002.83.0l2.5-2.5a2.002 2.002.0 00-2.83-2.83l-1.25 1.25a.751.751.0 01-1.042-.018.751.751.0 01-.018-1.042zm-4.69 9.64a1.998 1.998.0 002.83.0l1.25-1.25a.751.751.0 011.042.018.751.751.0 01.018 1.042l-1.25 1.25a3.5 3.5.0 11-4.95-4.95l2.5-2.5a3.5 3.5.0 014.95.0.751.751.0 01-.018 1.042.751.751.0 01-1.042.018 1.998 1.998.0 00-2.83.0l-2.5 2.5a1.998 1.998.0 000 2.83z"/></svg></a></h2><p>在本节中，我们将介绍 <strong>DigFuzz</strong> 的系统设计和实现细节。</p><h3 id=system-overview class=heading-element><span>6.1 System Overview</span>
<a href=#system-overview class=heading-mark><svg class="octicon octicon-link" viewBox="0 0 16 16" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5.0 114.95 4.95l-2.5 2.5a3.5 3.5.0 01-4.95.0.751.751.0 01.018-1.042.751.751.0 011.042-.018 1.998 1.998.0 002.83.0l2.5-2.5a2.002 2.002.0 00-2.83-2.83l-1.25 1.25a.751.751.0 01-1.042-.018.751.751.0 01-.018-1.042zm-4.69 9.64a1.998 1.998.0 002.83.0l1.25-1.25a.751.751.0 011.042.018.751.751.0 01.018 1.042l-1.25 1.25a3.5 3.5.0 11-4.95-4.95l2.5-2.5a3.5 3.5.0 014.95.0.751.751.0 01-.018 1.042.751.751.0 01-1.042.018 1.998 1.998.0 00-2.83.0l-2.5 2.5a1.998 1.998.0 000 2.83z"/></svg></a></h3><p>图3显示了<code>DigFuzz</code>的概述。它由三个主要部分组成：1）模糊器; 2）$MCP^3$模型; 3）符号执行器。<figure><a class=lightgallery href="https://cdn.haoyep.com/gh/leegical/Blog_img/md_img202312101450165.png?size=large" data-thumbnail="https://cdn.haoyep.com/gh/leegical/Blog_img/md_img202312101450165.png?size=small" data-sub-html="<h2> </h2><p>Fig. 3: Overview of DigFuzz</p>"><img loading=lazy src=https://cdn.haoyep.com/gh/leegical/Blog_img/md_img202312101450165.png alt="Fig. 3: Overview of DigFuzz" srcset="https://cdn.haoyep.com/gh/leegical/Blog_img/md_img202312101450165.png?size=small, https://cdn.haoyep.com/gh/leegical/Blog_img/md_img202312101450165.png?size=medium 1.5x, https://cdn.haoyep.com/gh/leegical/Blog_img/md_img202312101450165.png?size=large 2x" data-title="Fig. 3: Overview of DigFuzz" style="background:url(/images/loading.min.svg)no-repeat 50%" onload='this.title=this.dataset.title;for(const e of["style","data-title","onerror","onload"])this.removeAttribute(e);this.dataset.lazyloaded=""' onerror='this.title=this.dataset.title;for(const e of["style","data-title","onerror","onload"])this.removeAttribute(e)'></a><figcaption class=image-caption>Fig. 3: Overview of DigFuzz</figcaption></figure></p><p>我们的系统利用流行的现成模糊器，American Fuzzy Lop（AFL）[47]作为模糊测试组件，并在 angr [38]之上构建了一个符号执行器，这是一个开源符号执行引擎，与 <code>Driller</code> 相同[39]。</p><p><code>DigFuzz</code> 中最重要的组件是$MCP^3$模型。该组件执行<code>execution sampling</code>，构造基于$MCP^3$的执行树，基于概率计算对路径进行优先级排序，并最终将优先路径馈送到 concolic 执行器。</p><p>DigFuzz 通过使用初始种子输入启动测试。只要模糊测试器生成输入，$MCP^3$模型就会执行<code>execution sampling</code>以收集覆盖率统计信息，这些统计信息指示采样期间每个分支被覆盖的次数。同时，它还通过跟踪分析构建基于$MCP^3$的执行树，并使用从覆盖统计计算的概率标记树的所有分支。一旦构造了树并且路径用概率标记，则$MCP^3$模型优先考虑树中的所有遗漏路径，并识别具有最低概率执行的路径。</p><p>由于为了简化路径约束，符号执行同时在具体值和符号值上执行程序，一旦一个被优先的未遗漏路径被识别，$MCP^3$模型还会确定一个相应的输入，该输入可以引导符号执行达到遗漏的路径。也就是说，通过将输入作为具体值，符号执行器可以沿着遗漏路径的前缀执行程序，生成并收集符号路径约束。当到达遗漏分支时，它可以通过将<code>路径前缀的约束</code>与<code>到达该遗漏分支的条件</code>相结合来生成错过路径的约束。最后，<code>concolic executor</code>通过解决路径约束生成遗漏路径的输入，并将生成的输入反馈给模糊器。同时，它还通过符号执行期间已探索的路径更新执行树。通过利用来自符号执行的新输入，模糊器将能够深入探索、扩展代码覆盖并更新执行树。</p><p>总之，<code>DigFuzz</code> 迭代工作。在每次迭代中，$MCP^3$模型通过对模糊器保留的所有输入的跟踪分析来更新执行树。然后，该模型使用执行样本的覆盖统计为每个分支标记其概率。之后，$MCP^3$模型对所有遗漏路径进行优先排序，并选择具有最低执行概率的路径进行符号执行。符号执行器将为跟踪中的遗漏分支生成输入，将通过符号执行期间已探索的路径更新执行树。完成这些步骤后，<code>DigFuzz</code> 将进入另一轮迭代。</p><h3 id=execution-sampling class=heading-element><span>6.2 Execution Sampling</span>
<a href=#execution-sampling class=heading-mark><svg class="octicon octicon-link" viewBox="0 0 16 16" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5.0 114.95 4.95l-2.5 2.5a3.5 3.5.0 01-4.95.0.751.751.0 01.018-1.042.751.751.0 011.042-.018 1.998 1.998.0 002.83.0l2.5-2.5a2.002 2.002.0 00-2.83-2.83l-1.25 1.25a.751.751.0 01-1.042-.018.751.751.0 01-.018-1.042zm-4.69 9.64a1.998 1.998.0 002.83.0l1.25-1.25a.751.751.0 011.042.018.751.751.0 01.018 1.042l-1.25 1.25a3.5 3.5.0 11-4.95-4.95l2.5-2.5a3.5 3.5.0 014.95.0.751.751.0 01-.018 1.042.751.751.0 01-1.042.018 1.998 1.998.0 00-2.83.0l-2.5 2.5a1.998 1.998.0 000 2.83z"/></svg></a></h3><p>DigFuzz 需要进行随机抽样来使用蒙特卡罗方法计算概率[35]。基于模糊器的性质就是生成随机输入，我们将模糊过程视对整个程序状态空间的随机抽样过程。由于模糊测试的高吞吐量，生成的样本数量将很快变得足够大，具有统计意义，这由三个规则定义[43]，其中当样本数大于30时，从0到$3/n$的区间是95%的置信区间。</p><p>基于这一观察，我们提出了执行抽样的算法（Algorithm 1）。该算法接受3个输入并在 $HashMap$ 中生成 coverage 统计信息。</p><div class="alert alert-tip"><p class=alert-title><svg class="icon" viewBox="0 0 16 16" width="16" height="16"><path d="M8 1.5c-2.363.0-4 1.69-4 3.75.0.984.424 1.625.984 2.304l.214.253c.223.264.47.556.673.848.284.411.537.896.621 1.49a.75.75.0 01-1.484.211c-.04-.282-.163-.547-.37-.847a8.456 8.456.0 00-.542-.68c-.084-.1-.173-.205-.268-.32C3.201 7.75 2.5 6.766 2.5 5.25 2.5 2.31 4.863.0 8 0s5.5 2.31 5.5 5.25c0 1.516-.701 2.5-1.328 3.259-.095.115-.184.22-.268.319-.207.245-.383.453-.541.681-.208.3-.33.565-.37.847a.751.751.0 01-1.485-.212c.084-.593.337-1.078.621-1.489.203-.292.45-.584.673-.848.075-.088.147-.173.213-.253.561-.679.985-1.32.985-2.304.0-2.06-1.637-3.75-4-3.75zM5.75 12h4.5a.75.75.0 010 1.5h-4.5a.75.75.0 010-1.5zM6 15.25a.75.75.0 01.75-.75h2.5a.75.75.0 010 1.5h-2.5A.75.75.0 016 15.25z"/></svg>提示</p><p><ul><li>算法1的3个输入
1）目标二进制$P$； 2）模糊测试器$Fuzzer$； 3）存储在$Set_{inputs}$中的初始种子</li></ul></div><p>给定这3个输入，算法在模糊测试过程中进行迭代抽样。</p><ol><li>$Fuzzer$使用$P$和$Set_{inputs}$以生成新输入 $Set_{NewInputs}$（Ln.7）。</li><li>然后，对于 $NewInputs$ 中的每个输入，我们收集由$P$和$input$（Ln.9）确定的路径内的每个分支的覆盖统计信息，并进一步更新存储在$HashMap_{CovStat}$中的现有覆盖统计（Ln.11和12）。</li><li>最后，算法将$Set_{NewInputs}$合并到$Set_{inputs}$（Ln.15）并开始新的迭代。<figure><a class=lightgallery href="https://cdn.haoyep.com/gh/leegical/Blog_img/md_img202312101445625.png?size=large" data-thumbnail="https://cdn.haoyep.com/gh/leegical/Blog_img/md_img202312101445625.png?size=small" data-sub-html="<h2> </h2><p>Algorithm 1 Execution Sampling</p>"><img loading=lazy src=https://cdn.haoyep.com/gh/leegical/Blog_img/md_img202312101445625.png alt="Algorithm 1 Execution Sampling" srcset="https://cdn.haoyep.com/gh/leegical/Blog_img/md_img202312101445625.png?size=small, https://cdn.haoyep.com/gh/leegical/Blog_img/md_img202312101445625.png?size=medium 1.5x, https://cdn.haoyep.com/gh/leegical/Blog_img/md_img202312101445625.png?size=large 2x" data-title="Algorithm 1 Execution Sampling" style="background:url(/images/loading.min.svg)no-repeat 50%" onload='this.title=this.dataset.title;for(const e of["style","data-title","onerror","onload"])this.removeAttribute(e);this.dataset.lazyloaded=""' onerror='this.title=this.dataset.title;for(const e of["style","data-title","onerror","onload"])this.removeAttribute(e)'></a><figcaption class=image-caption>Algorithm 1 Execution Sampling</figcaption></figure></li></ol><h3 id=execution-tree-construction class=heading-element><span>6.3 Execution Tree Construction</span>
<a href=#execution-tree-construction class=heading-mark><svg class="octicon octicon-link" viewBox="0 0 16 16" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5.0 114.95 4.95l-2.5 2.5a3.5 3.5.0 01-4.95.0.751.751.0 01.018-1.042.751.751.0 011.042-.018 1.998 1.998.0 002.83.0l2.5-2.5a2.002 2.002.0 00-2.83-2.83l-1.25 1.25a.751.751.0 01-1.042-.018.751.751.0 01-.018-1.042zm-4.69 9.64a1.998 1.998.0 002.83.0l1.25-1.25a.751.751.0 011.042.018.751.751.0 01.018 1.042l-1.25 1.25a3.5 3.5.0 11-4.95-4.95l2.5-2.5a3.5 3.5.0 014.95.0.751.751.0 01-.018 1.042.751.751.0 01-1.042.018 1.998 1.998.0 00-2.83.0l-2.5 2.5a1.998 1.998.0 000 2.83z"/></svg></a></h3><p>如图3所示，DigFuzz 使用来自模糊器的运行时信息生成基于$MCP^3$的执行树。<figure><a class=lightgallery href="https://cdn.haoyep.com/gh/leegical/Blog_img/md_img202312101450165.png?size=large" data-thumbnail="https://cdn.haoyep.com/gh/leegical/Blog_img/md_img202312101450165.png?size=small" data-sub-html="<h2> </h2><p>Fig. 3: Overview of DigFuzz</p>"><img loading=lazy src=https://cdn.haoyep.com/gh/leegical/Blog_img/md_img202312101450165.png alt="Fig. 3: Overview of DigFuzz" srcset="https://cdn.haoyep.com/gh/leegical/Blog_img/md_img202312101450165.png?size=small, https://cdn.haoyep.com/gh/leegical/Blog_img/md_img202312101450165.png?size=medium 1.5x, https://cdn.haoyep.com/gh/leegical/Blog_img/md_img202312101450165.png?size=large 2x" data-title="Fig. 3: Overview of DigFuzz" style="background:url(/images/loading.min.svg)no-repeat 50%" onload='this.title=this.dataset.title;for(const e of["style","data-title","onerror","onload"])this.removeAttribute(e);this.dataset.lazyloaded=""' onerror='this.title=this.dataset.title;for(const e of["style","data-title","onerror","onload"])this.removeAttribute(e)'></a><figcaption class=image-caption>Fig. 3: Overview of DigFuzz</figcaption></figure></p><div class="alert alert-tip"><p class=alert-title><svg class="icon" viewBox="0 0 16 16" width="16" height="16"><path d="M8 1.5c-2.363.0-4 1.69-4 3.75.0.984.424 1.625.984 2.304l.214.253c.223.264.47.556.673.848.284.411.537.896.621 1.49a.75.75.0 01-1.484.211c-.04-.282-.163-.547-.37-.847a8.456 8.456.0 00-.542-.68c-.084-.1-.173-.205-.268-.32C3.201 7.75 2.5 6.766 2.5 5.25 2.5 2.31 4.863.0 8 0s5.5 2.31 5.5 5.25c0 1.516-.701 2.5-1.328 3.259-.095.115-.184.22-.268.319-.207.245-.383.453-.541.681-.208.3-.33.565-.37.847a.751.751.0 01-1.485-.212c.084-.593.337-1.078.621-1.489.203-.292.45-.584.673-.848.075-.088.147-.173.213-.253.561-.679.985-1.32.985-2.304.0-2.06-1.637-3.75-4-3.75zM5.75 12h4.5a.75.75.0 010 1.5h-4.5a.75.75.0 010-1.5zM6 15.25a.75.75.0 01.75-.75h2.5a.75.75.0 010 1.5h-2.5A.75.75.0 016 15.25z"/></svg>提示</p><p><ul><li>Algorithm 2的输入、输出
输入，也是<code>Algorithm 1</code>的输出：
1）目标二进制文件的控制流图$CFG$；
2）fuzzer 保留的输入$Set_{inputs}$；
3）覆盖统计$HashMap_{CovStat}$</li></ul><p>输出：基于$MCP^3$的执行树 $ExecTree$</p></div><p><code>Algorithm 2</code>展示了树构建过程。算法主要分为两个步骤。</p><ul><li><strong>Step1</strong>：对 $Set_{inputs}$中的每个输入执行跟踪分析，提取相应的跟踪，然后将跟踪合并到 $ExecTree$ 中（Ln. 6到11）</li><li><strong>Step2</strong>：计算执行树中每个分支的概率（Ln. 12到16）。<ul><li>为实现这一点，对于 $ExecTree$ 中的每个分支$b_{ri}$，我们通过检查 $CFG$（Ln. 13）提取其相邻分支$b_{rj}$（$b_{ri}$和$b_{rj}$共享包含条件检查的相同前继块）。</li><li>然后，算法利用方程1计算$b_{ri}$的概率（Ln. 14）。</li><li>之后，算法使用计算得到的概率标记执行树 $ExecTree$（Ln. 15）并输出新标记的 $ExecTree$。<figure><a class=lightgallery href="https://cdn.haoyep.com/gh/leegical/Blog_img/md_img202312101447190.png?size=large" data-thumbnail="https://cdn.haoyep.com/gh/leegical/Blog_img/md_img202312101447190.png?size=small" data-sub-html="<h2> </h2><p>Algorithm 2 Execution Tree Construction</p>"><img loading=lazy src=https://cdn.haoyep.com/gh/leegical/Blog_img/md_img202312101447190.png alt="Algorithm 2 Execution Tree Construction" srcset="https://cdn.haoyep.com/gh/leegical/Blog_img/md_img202312101447190.png?size=small, https://cdn.haoyep.com/gh/leegical/Blog_img/md_img202312101447190.png?size=medium 1.5x, https://cdn.haoyep.com/gh/leegical/Blog_img/md_img202312101447190.png?size=large 2x" data-title="Algorithm 2 Execution Tree Construction" style="background:url(/images/loading.min.svg)no-repeat 50%" onload='this.title=this.dataset.title;for(const e of["style","data-title","onerror","onload"])this.removeAttribute(e);this.dataset.lazyloaded=""' onerror='this.title=this.dataset.title;for(const e of["style","data-title","onerror","onload"])this.removeAttribute(e)'></a><figcaption class=image-caption>Algorithm 2 Execution Tree Construction</figcaption></figure></li></ul></li></ul><p>为了避免执行树中潜在的<strong>路径爆炸</strong>问题，我们只对由模糊测试保留的种子输入执行跟踪分析。模糊器通常将那些具有新代码覆盖的突变输入视为进一步突变的种子。对这些保留的种子进行跟踪是一种有前景的方法，可以对探索的程序状态进行建模。对于沿着执行跟踪的每个分支，只要模糊测试器尚未覆盖相反分支，就标识为一个遗漏路径，该路径指的是与未覆盖的分支连接的跟踪前缀。换句话说，执行树不会包括一个相反分支尚未被覆盖的遗漏分支。</p><p>为了简化表示，我们提供了一个运行示例，它简化了CQE数据集[13]中的程序，代码如图4所示。漏洞由特定字符串保护，很难进行模糊检测。<figure><a class=lightgallery href="https://cdn.haoyep.com/gh/leegical/Blog_img/md_img202312101535292.png?size=large" data-thumbnail="https://cdn.haoyep.com/gh/leegical/Blog_img/md_img202312101535292.png?size=small" data-sub-html="<h2> </h2><p>图4.运行示例</p>"><img loading=lazy src=https://cdn.haoyep.com/gh/leegical/Blog_img/md_img202312101535292.png alt=图4.运行示例 srcset="https://cdn.haoyep.com/gh/leegical/Blog_img/md_img202312101535292.png?size=small, https://cdn.haoyep.com/gh/leegical/Blog_img/md_img202312101535292.png?size=medium 1.5x, https://cdn.haoyep.com/gh/leegical/Blog_img/md_img202312101535292.png?size=large 2x" data-title=图4.运行示例 style="background:url(/images/loading.min.svg)no-repeat 50%" onload='this.title=this.dataset.title;for(const e of["style","data-title","onerror","onload"])this.removeAttribute(e);this.dataset.lazyloaded=""' onerror='this.title=this.dataset.title;for(const e of["style","data-title","onerror","onload"])this.removeAttribute(e)'></a><figcaption class=image-caption>图4.运行示例</figcaption></figure></p><p>图5示出了用于图4中的运行示例的基于$MCP^3$的执行树。每个节点表示一个基本块。每条边都是一个用概率标记的分支。可以观察到树中有2个<code>trace</code>（红色：$t1 =⟨b1，b2，b6，b12，b13，b7，b9，b11⟩$和蓝色：$t2 =⟨b1，b3，b4，b12，b14⟩$）。请注意，概率是通过多个执行样本计算的。在此示例中，我们为了简化呈现仅提供了两个跟踪。<figure><a class=lightgallery href="https://cdn.haoyep.com/gh/leegical/Blog_img/md_img202312101538774.png?size=large" data-thumbnail="https://cdn.haoyep.com/gh/leegical/Blog_img/md_img202312101538774.png?size=small" data-sub-html="<h2> </h2><p>图5：具有概率的执行树</p>"><img loading=lazy src=https://cdn.haoyep.com/gh/leegical/Blog_img/md_img202312101538774.png alt=图5：具有概率的执行树 srcset="https://cdn.haoyep.com/gh/leegical/Blog_img/md_img202312101538774.png?size=small, https://cdn.haoyep.com/gh/leegical/Blog_img/md_img202312101538774.png?size=medium 1.5x, https://cdn.haoyep.com/gh/leegical/Blog_img/md_img202312101538774.png?size=large 2x" data-title=图5：具有概率的执行树 style="background:url(/images/loading.min.svg)no-repeat 50%" onload='this.title=this.dataset.title;for(const e of["style","data-title","onerror","onload"])this.removeAttribute(e);this.dataset.lazyloaded=""' onerror='this.title=this.dataset.title;for(const e of["style","data-title","onerror","onload"])this.removeAttribute(e)'></a><figcaption class=image-caption>图5：具有概率的执行树</figcaption></figure></p><h3 id=probabilistic-path-prioritization class=heading-element><span>6.4 Probabilistic Path Prioritization</span>
<a href=#probabilistic-path-prioritization class=heading-mark><svg class="octicon octicon-link" viewBox="0 0 16 16" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5.0 114.95 4.95l-2.5 2.5a3.5 3.5.0 01-4.95.0.751.751.0 01.018-1.042.751.751.0 011.042-.018 1.998 1.998.0 002.83.0l2.5-2.5a2.002 2.002.0 00-2.83-2.83l-1.25 1.25a.751.751.0 01-1.042-.018.751.751.0 01-.018-1.042zm-4.69 9.64a1.998 1.998.0 002.83.0l1.25-1.25a.751.751.0 011.042.018.751.751.0 01.018 1.042l-1.25 1.25a3.5 3.5.0 11-4.95-4.95l2.5-2.5a3.5 3.5.0 014.95.0.751.751.0 01-.018 1.042.751.751.0 01-1.042.018 1.998 1.998.0 00-2.83.0l-2.5 2.5a1.998 1.998.0 000 2.83z"/></svg></a></h3><p>我们基于概率对路径进行优先排序。如方程2所示，路径被视为一个马尔可夫链，其概率是基于路径内所有分支的概率计算得出的。路径可以表示为一系列已覆盖的分支，每个分支都标记有其概率，该概率表示随机输入能够满足条件的可能性有多大。因此，我们利用马尔可夫链模型，将路径的概率看作是转换的概率序列。<figure><a class=lightgallery href="https://cdn.haoyep.com/gh/leegical/Blog_img/md_img202312101709167.png?size=large" data-thumbnail="https://cdn.haoyep.com/gh/leegical/Blog_img/md_img202312101709167.png?size=small" data-sub-html="<h2> </h2><p>算法3. DigFuzz中的路径优先排序</p>"><img loading=lazy src=https://cdn.haoyep.com/gh/leegical/Blog_img/md_img202312101709167.png alt="算法3. DigFuzz中的路径优先排序" srcset="https://cdn.haoyep.com/gh/leegical/Blog_img/md_img202312101709167.png?size=small, https://cdn.haoyep.com/gh/leegical/Blog_img/md_img202312101709167.png?size=medium 1.5x, https://cdn.haoyep.com/gh/leegical/Blog_img/md_img202312101709167.png?size=large 2x" data-title="算法3. DigFuzz中的路径优先排序" style="background:url(/images/loading.min.svg)no-repeat 50%" onload='this.title=this.dataset.title;for(const e of["style","data-title","onerror","onload"])this.removeAttribute(e);this.dataset.lazyloaded=""' onerror='this.title=this.dataset.title;for(const e of["style","data-title","onerror","onload"])this.removeAttribute(e)'></a><figcaption class=image-caption>算法3. DigFuzz中的路径优先排序</figcaption></figure></p><div class="alert alert-tip"><p class=alert-title><svg class="icon" viewBox="0 0 16 16" width="16" height="16"><path d="M8 1.5c-2.363.0-4 1.69-4 3.75.0.984.424 1.625.984 2.304l.214.253c.223.264.47.556.673.848.284.411.537.896.621 1.49a.75.75.0 01-1.484.211c-.04-.282-.163-.547-.37-.847a8.456 8.456.0 00-.542-.68c-.084-.1-.173-.205-.268-.32C3.201 7.75 2.5 6.766 2.5 5.25 2.5 2.31 4.863.0 8 0s5.5 2.31 5.5 5.25c0 1.516-.701 2.5-1.328 3.259-.095.115-.184.22-.268.319-.207.245-.383.453-.541.681-.208.3-.33.565-.37.847a.751.751.0 01-1.485-.212c.084-.593.337-1.078.621-1.489.203-.292.45-.584.673-.848.075-.088.147-.173.213-.253.561-.679.985-1.32.985-2.304.0-2.06-1.637-3.75-4-3.75zM5.75 12h4.5a.75.75.0 010 1.5h-4.5a.75.75.0 010-1.5zM6 15.25a.75.75.0 01.75-.75h2.5a.75.75.0 010 1.5h-2.5A.75.75.0 016 15.25z"/></svg>提示</p><p>Algorithm 3的输入、输出
输入，也是<code>Algorithm 2</code>的输出：基于$MCP^3$的执行树$ExecTree$</p><p>输出：$Set_{Prob}$，一组未探索（遗漏）的路径及其概率</p></div><p><code>Algorithm 3</code>详细地呈现了这个算法。<code>DigFuzz</code> 将根据$Set_{Prob}$对这些 <strong>未探索（遗漏）</strong> 的路径进行进一步的优先排序，并将概率最低的路径提供给符号执行。该算法：</p><ol><li>从执行树遍历开始。对于 $ExecTree$ 中每个跟踪上的每个分支$b_{ri}$，它首先提取相邻的分支$b_{rj}$（Ln. 5），然后收集沿给定跟踪未探索的路径（Ln. 6）。</li><li>然后，算法通过调用实现方程2的 $CalPathProb()$ 计算了未探索路径的概率，并将信息存储在 $Set_{Prob}$中。</li><li>最终，该算法生成$Set_{Prob}$，即每个跟踪的未探索路径及其概率。</li></ol><p>得到$Set_{Prob}$后，我们将</p><ol><li>按概率降序对未探索路径进行优先排序，并确定<strong>概率最低的路径</strong>供符号执行使用。</li><li>确定输入，引导 concolic 执行器优先探索概率最低的路径。</li></ol><p>以图4中的程序为例。在图5中，未探索（遗漏）的分支显示为虚线。在构建了执行树并正确标记之后，使用 <code>Algorithm 3</code>来获取未探索的路径并计算这些路径的概率。我们可以观察到总共有4条未探索的路径，分别记为$P_1$、$P_2$、$P_3$和$P_4$。通过调用 $CalPathProb()$ 函数，这些未探索路径的概率如图中所示计算，其中概率最低的路径是$P_1$。为了引导 concolic 执行器探索$P_1$，<code>DigFuzz</code>将选择导致跟踪$〈b1, b2, b6, b12, b13, b7, b9, b11〉$的输入，并将此输入分配为 concolic 执行的具体值，因为此跟踪与未探索路径$P_1$共享相同的路径前缀$〈b1, b2, b6, b12, b13, b7, b9〉$。</p><h2 id=discussion class=heading-element><span>7 Discussion</span>
<a href=#discussion class=heading-mark><svg class="octicon octicon-link" viewBox="0 0 16 16" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5.0 114.95 4.95l-2.5 2.5a3.5 3.5.0 01-4.95.0.751.751.0 01.018-1.042.751.751.0 011.042-.018 1.998 1.998.0 002.83.0l2.5-2.5a2.002 2.002.0 00-2.83-2.83l-1.25 1.25a.751.751.0 01-1.042-.018.751.751.0 01-.018-1.042zm-4.69 9.64a1.998 1.998.0 002.83.0l1.25-1.25a.751.751.0 011.042.018.751.751.0 01.018 1.042l-1.25 1.25a3.5 3.5.0 11-4.95-4.95l2.5-2.5a3.5 3.5.0 014.95.0.751.751.0 01-.018 1.042.751.751.0 01-1.042.018 1.998 1.998.0 00-2.83.0l-2.5 2.5a1.998 1.998.0 000 2.83z"/></svg></a></h2><h3 id=threats-to-validity class=heading-element><span>7.1 Threats to Validity</span>
<a href=#threats-to-validity class=heading-mark><svg class="octicon octicon-link" viewBox="0 0 16 16" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5.0 114.95 4.95l-2.5 2.5a3.5 3.5.0 01-4.95.0.751.751.0 01.018-1.042.751.751.0 011.042-.018 1.998 1.998.0 002.83.0l2.5-2.5a2.002 2.002.0 00-2.83-2.83l-1.25 1.25a.751.751.0 01-1.042-.018.751.751.0 01-.018-1.042zm-4.69 9.64a1.998 1.998.0 002.83.0l1.25-1.25a.751.751.0 011.042.018.751.751.0 01.018 1.042l-1.25 1.25a3.5 3.5.0 11-4.95-4.95l2.5-2.5a3.5 3.5.0 014.95.0.751.751.0 01-.018 1.042.751.751.0 01-1.042.018 1.998 1.998.0 00-2.83.0l-2.5 2.5a1.998 1.998.0 000 2.83z"/></svg></a></h3><p>我们的实验结果基于论文中提供的有限数据集。已经努力在实际程序上评估 <code>DigFuzz</code>，但是当 Angr [38]遇到不支持的系统调用时，它无法对程序进行符号执行。因此，结果可能无法完全代表实际程序。对这些程序进行评估是必要的，以便就拟议技术在实践中的有效性得出结论。我们将把对真实世界程序的评估留作未来的工作。</p><h3 id=limitations class=heading-element><span>7.2 Limitations</span>
<a href=#limitations class=heading-mark><svg class="octicon octicon-link" viewBox="0 0 16 16" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5.0 114.95 4.95l-2.5 2.5a3.5 3.5.0 01-4.95.0.751.751.0 01.018-1.042.751.751.0 011.042-.018 1.998 1.998.0 002.83.0l2.5-2.5a2.002 2.002.0 00-2.83-2.83l-1.25 1.25a.751.751.0 01-1.042-.018.751.751.0 01-.018-1.042zm-4.69 9.64a1.998 1.998.0 002.83.0l1.25-1.25a.751.751.0 011.042.018.751.751.0 01.018 1.042l-1.25 1.25a3.5 3.5.0 11-4.95-4.95l2.5-2.5a3.5 3.5.0 014.95.0.751.751.0 01-.018 1.042.751.751.0 01-1.042.018 1.998 1.998.0 00-2.83.0l-2.5 2.5a1.998 1.998.0 000 2.83z"/></svg></a></h3><p>首先，虽然<code>DigFuzz</code>中的“区别性调度”被设计为轻量级方法，但它仍然会产生一些运行时和内存消耗开销，包括收集模糊测试的运行时信息和构造执行树。但根据评估，可以看到对于模糊测试的吞吐量减少是可以忽略不计的。此外，由于树中的每个节点仅携带非常有限的信息，因此执行树的总内存消耗是非常易于管理的。
其次，由于<code>DigFuzz</code>仅估计模糊探测器的路径难度，但没有考虑约束求解的复杂性，所以挑选的路径收集到的约束可能是不可解的，这可能导致浪费整个符号执行循环。此外，可能导致漏洞的最有希望的路径也可能不是<code>DigFuzz</code>选择的最难的路径。这两个限制是由于我们找到正确的探索路径的模型。我们考虑将它们解决为未来的工作。</p><h2 id=related-work class=heading-element><span>8 Related Work</span>
<a href=#related-work class=heading-mark><svg class="octicon octicon-link" viewBox="0 0 16 16" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5.0 114.95 4.95l-2.5 2.5a3.5 3.5.0 01-4.95.0.751.751.0 01.018-1.042.751.751.0 011.042-.018 1.998 1.998.0 002.83.0l2.5-2.5a2.002 2.002.0 00-2.83-2.83l-1.25 1.25a.751.751.0 01-1.042-.018.751.751.0 01-.018-1.042zm-4.69 9.64a1.998 1.998.0 002.83.0l1.25-1.25a.751.751.0 011.042.018.751.751.0 01.018 1.042l-1.25 1.25a3.5 3.5.0 11-4.95-4.95l2.5-2.5a3.5 3.5.0 014.95.0.751.751.0 01-.018 1.042.751.751.0 01-1.042.018 1.998 1.998.0 00-2.83.0l-2.5 2.5a1.998 1.998.0 000 2.83z"/></svg></a></h2><p><code>模糊测试 Fuzzing</code>和<code>符号执行 symbolic execution</code>是程序测试的两种主流技术。许多先前的努力已经致力于改进它们[3]，[27]，[33]，[36]。</p><p>BuzzFuzz [17]利用动态污点标记来识别由可疑指令处理的输入字节。Dowser [20]采用反向工程技术来识别与可疑功能相关的输入字段。Vuzzer [34]利用控制流和数据流特征来准确确定何时以及如何变异这些输入。Skyfire [40]利用现有样本中的知识生成用于模糊测试程序的分布良好的种子输入。Angora [12]旨在通过解决路径约束而不使用符号执行来增加分支覆盖。T-Fuzz [32]首先允许模糊测试器在去除了无法绕过的健全性检查的转换程序上工作。作为辅助的后处理步骤，T-Fuzz 利用基于符号执行的方法来过滤掉假阳性。CollAFL [16]是一种基于覆盖率敏感的模糊测试解决方案，通过提供更准确的覆盖信息来减轻路径冲突。它还利用覆盖信息应用了三种新的模糊测试策略。Veritesting [1]通过采用静态符号执行来放大动态符号执行的效果，以解决路径爆炸问题。Mayhem [10]提出将在线和离线符号执行结合起来处理内存耗尽的问题。</p><p><code>DigFuzz</code> 的主要贡献在于提出了一种更有效的策略，将模糊测试与符号执行结合起来。因此，模糊测试和符号执行的进展超出了我们的范围。</p><h3 id=hybrid-fuzzing-system class=heading-element><span>8.1 Hybrid fuzzing system</span>
<a href=#hybrid-fuzzing-system class=heading-mark><svg class="octicon octicon-link" viewBox="0 0 16 16" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5.0 114.95 4.95l-2.5 2.5a3.5 3.5.0 01-4.95.0.751.751.0 01.018-1.042.751.751.0 011.042-.018 1.998 1.998.0 002.83.0l2.5-2.5a2.002 2.002.0 00-2.83-2.83l-1.25 1.25a.751.751.0 01-1.042-.018.751.751.0 01-.018-1.042zm-4.69 9.64a1.998 1.998.0 002.83.0l1.25-1.25a.751.751.0 011.042.018.751.751.0 01.018 1.042l-1.25 1.25a3.5 3.5.0 11-4.95-4.95l2.5-2.5a3.5 3.5.0 014.95.0.751.751.0 01-.018 1.042.751.751.0 01-1.042.018 1.998 1.998.0 00-2.83.0l-2.5 2.5a1.998 1.998.0 000 2.83z"/></svg></a></h3><p>大多数混合模糊测试系统遵循通过选择性符号执行增强模糊测试的观察[9]，[27]，[38]，[40]。TaintScope [40]部署动态污点分析来识别校验点，然后应用符号执行生成满足校验和的输入。T-Fuzz [31]首先允许模糊测试器在经过去除健全性检查的转换程序上工作，然后利用基于符号执行的方法来过滤出假阳性。SAVIOR [13]提出了一种基于漏洞的混合模糊测试系统。它优先考虑具有更高潜力导致发现更多漏洞的种子进行合符号执行。此外，它在合符号执行期间启用了安全检查。HFL [25]将模糊测试与符号执行相结合，以解决内核特定的模糊测试挑战。PANGOLIN [23]设计了基于多面体路径抽象的增量混合模糊测试，该抽象在合符号执行阶段保留了探索状态，并允许对现有技术进行更有效的变异和约束求解。与这些技术相比，<code>DigFuzz</code> 通过基于覆盖统计量量化模糊测试探索路径的难度来优先考虑路径。</p><p>另一种混合模糊测试系统是将符号执行视为输入生成或路径选择的引导者。Pak [30]提出了一种混合模糊测试系统，将符号执行应用于收集路径约束，然后系统生成符合路径谓词并过渡到模糊测试器的输入。DeepFuzz [5]采用概率符号执行为程序路径分配概率，然后利用这些概率来引导模糊测试中的路径探索。</p><p>MDPC [42]提出了一种理论框架，用于最佳的符号测试。它基于程序路径的概率和约束求解的成本来定义最优策略，这与我们识别路径概率的想法类似。与使用重量级技术来计算模糊测试和符号执行成本的MDPC [42]相比，我们的模型使用覆盖率统计来计算概率，这更加轻巧和实用。</p><p>QSYM [46]使用动态二进制转换将符号仿真与本机执行集成在一起。 它还减轻了传统的严格健全性要求，减轻了传统的严格健全性要求，使其可扩展到现实世界的程序。 主要重点是使其可以扩展到真实世界的程序。 主要重点是使其可以扩展到真实世界的程序。 有选择地只派遣最难的工作的主要焦点。</p><h3 id=path-prioritization-in-symbolic-execution class=heading-element><span>8.2 Path prioritization in symbolic execution</span>
<a href=#path-prioritization-in-symbolic-execution class=heading-mark><svg class="octicon octicon-link" viewBox="0 0 16 16" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5.0 114.95 4.95l-2.5 2.5a3.5 3.5.0 01-4.95.0.751.751.0 01.018-1.042.751.751.0 011.042-.018 1.998 1.998.0 002.83.0l2.5-2.5a2.002 2.002.0 00-2.83-2.83l-1.25 1.25a.751.751.0 01-1.042-.018.751.751.0 01-.018-1.042zm-4.69 9.64a1.998 1.998.0 002.83.0l1.25-1.25a.751.751.0 011.042.018.751.751.0 01.018 1.042l-1.25 1.25a3.5 3.5.0 11-4.95-4.95l2.5-2.5a3.5 3.5.0 014.95.0.751.751.0 01-.018 1.042.751.751.0 01-1.042.018 1.998 1.998.0 00-2.83.0l-2.5 2.5a1.998 1.998.0 000 2.83z"/></svg></a></h3><p>路径优先化有望减轻动态符号执行中的路径爆炸问题。代表性研究包括启发式技术和声音程序分析技术[9]。这些启发式方法包括使用控制流图来指导探索，基于频率和基于随机的技术[6] - [8]。最近，采用路径优先级与进化搜索相结合，其中定义适应度函数来指导符号执行[2]。与这些路径探索技术相比，<code>DigFuzz</code>中的路径优先级是将具有概率的路径优先化为模糊测试的难度。据我们所知，我们是第一个研究混合模糊测试系统中的路径优先级问题的人。</p><p>定向符号执行还使用路径优先级来达到目标。这些技术旨在为目标语句或分支搜索可行路径[37]，[45]。与有向符号执行技术相比，<code>DigFuzz</code>中的路径优先级是识别用于执行的目标路径，而不是为给定目标搜索可行路径。</p><h3 id=seed-scheduling-in-fuzzing class=heading-element><span>8.3 Seed scheduling in fuzzing</span>
<a href=#seed-scheduling-in-fuzzing class=heading-mark><svg class="octicon octicon-link" viewBox="0 0 16 16" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5.0 114.95 4.95l-2.5 2.5a3.5 3.5.0 01-4.95.0.751.751.0 01.018-1.042.751.751.0 011.042-.018 1.998 1.998.0 002.83.0l2.5-2.5a2.002 2.002.0 00-2.83-2.83l-1.25 1.25a.751.751.0 01-1.042-.018.751.751.0 01-.018-1.042zm-4.69 9.64a1.998 1.998.0 002.83.0l1.25-1.25a.751.751.0 011.042.018.751.751.0 01.018 1.042l-1.25 1.25a3.5 3.5.0 11-4.95-4.95l2.5-2.5a3.5 3.5.0 014.95.0.751.751.0 01-.018 1.042.751.751.0 01-1.042.018 1.998 1.998.0 00-2.83.0l-2.5 2.5a1.998 1.998.0 000 2.83z"/></svg></a></h3><p>种子选择在模糊测试中起着重要作用，并且已经提出了一些研究来通过优先考虑种子投入来改进种子调度[4]，[11]，[44]。 Woo等人。 [44]模型黑盒模糊作为一个多臂强盗问题，其中种子的能量是根据它是否在任何先前的模糊迭代中暴露出崩溃来计算的。 AFLfast [4]通过为AFL较少采用的输入分配更多能量来改进AFL的种子选择策略。这些种子调度技术背后的基本见解是搜索变异执行更有可能发现新程序状态的种子。在我们未来的工作中，我们计划设计调度技术，以便使用难以探索的路径卸载模糊器。</p><p>测试用例优先级尝试以提高检测到错误率的方式重新排序测试用例[21]，[22]，[24]，[26]，[28]。 本研究中的路径优先级是为了获得最有可能阻塞模糊器的错过路径。 搜索算法也与基于搜索的测试优先级和其他基于搜索的软件工程密切相关[23]。</p><h2 id=conclusion class=heading-element><span>9 Conclusion</span>
<a href=#conclusion class=heading-mark><svg class="octicon octicon-link" viewBox="0 0 16 16" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5.0 114.95 4.95l-2.5 2.5a3.5 3.5.0 01-4.95.0.751.751.0 01.018-1.042.751.751.0 011.042-.018 1.998 1.998.0 002.83.0l2.5-2.5a2.002 2.002.0 00-2.83-2.83l-1.25 1.25a.751.751.0 01-1.042-.018.751.751.0 01-.018-1.042zm-4.69 9.64a1.998 1.998.0 002.83.0l1.25-1.25a.751.751.0 011.042.018.751.751.0 01.018 1.042l-1.25 1.25a3.5 3.5.0 11-4.95-4.95l2.5-2.5a3.5 3.5.0 014.95.0.751.751.0 01-.018 1.042.751.751.0 01-1.042.018 1.998 1.998.0 00-2.83.0l-2.5 2.5a1.998 1.998.0 000 2.83z"/></svg></a></h2><ol><li>指出了一些最先进的混合模糊测试系统中采用的“需求启动”和“最优切换”策略中的一些根本限制。</li><li>进一步提出了一种<code>discriminative dispatch</code>策略：通过设计一个基于<code>Monte Carlo</code>的概率路径优先模型来更好地利用<code>concolic execution</code>的能力，以量化每条路径的难度。</li><li>实现了原型系统<code>DigFuzz</code>。评估结果显示，与最先进的混合模糊测试系统相比，<code>DigFuzz</code> 对于增加代码覆盖和发现漏洞的数量贡献更大。</li></ol></div><hr class=awesome-hr><h2 id=see-also>相关内容</h2><ul><li><a href=/posts/afl-install/ title="Ubuntu 22.04 安装 AFL 及 qemu mode 实践">Ubuntu 22.04 安装 AFL 及 qemu mode 实践</a></li><li><a href=/posts/optimize-github-pages-blog-access-speed/ title="Github Pages 博客网站访问速度优化">Github Pages 博客网站访问速度优化</a></li><li><a href=/posts/github-graph-beds-cdn/ title="通过 Cloudflare 和 jsDelivr 免费加速博客 GitHub 图床等静态资源">通过 Cloudflare 和 jsDelivr 免费加速博客 GitHub 图床等静态资源</a></li><li><a href=/posts/github-graph-beds/ title="使用PicGo + GitHub 搭建 Obsidian 图床">使用PicGo + GitHub 搭建 Obsidian 图床</a></li><li><a href=/posts/ptatm-1/ title=PTATM（一）：初始化工作>PTATM（一）：初始化工作</a></li></ul><div class=post-footer id=post-footer><div class=post-info><div class=post-info-line><div class=post-info-mod><span title="更新于 2025-01-24 00:48:27">更新于 2025-01-24&nbsp;</span></div><div class=post-info-license><span><a rel="license external nofollow noopener noreffer" href=https://creativecommons.org/licenses/by-nc/4.0/ target=_blank>CC BY-NC 4.0</a></span></div></div><div class=post-info-line><div class=post-info-md><span><a href=/posts/digfuzz/index.md title=阅读原始文档 class=link-to-markdown>阅读原始文档</a></span><span><a href="https://github.com/leegical/blog/blob/main/content/posts/%e7%a7%91%e7%a0%94/Digfuzz.md?plain=1" title=查看源码 target=_blank rel="external nofollow noopener noreferrer" class=link-to-source>查看源码</a></span><span><a href=https://github.com/leegical/blog/edit/main/content/posts/%e7%a7%91%e7%a0%94/Digfuzz.md title=编辑此页 target=_blank rel="external nofollow noopener noreferrer" class=link-to-edit>编辑此页</a></span></div><div class=post-info-share><span><a href=javascript:void(0); title="分享到 X" data-sharer=twitter data-url=https://www.haoyep.com/posts/digfuzz/ data-title=Digfuzz工具论文调研 data-hashtags=论文,符号执行,模糊测试><i class="fa-brands fa-x-twitter fa-fw" aria-hidden=true></i></a>
<a href=javascript:void(0); title="分享到 Facebook" data-sharer=facebook data-url=https://www.haoyep.com/posts/digfuzz/ data-hashtag=论文><i class="fa-brands fa-facebook-square fa-fw" aria-hidden=true></i></a>
<a href=javascript:void(0); title="分享到 Linkedin" data-sharer=linkedin data-url=https://www.haoyep.com/posts/digfuzz/><i class="fa-brands fa-linkedin fa-fw" aria-hidden=true></i></a>
<a href=javascript:void(0); title="分享到 微博" data-sharer=weibo data-url=https://www.haoyep.com/posts/digfuzz/ data-title=Digfuzz工具论文调研 data-image=https://cdn.haoyep.com/gh/leegical/Blog_img/cdnimg/202401171503941.png><i class="fa-brands fa-weibo fa-fw" aria-hidden=true></i></a>
<a href=javascript:void(0); title="分享到 百度" data-sharer=baidu data-url=https://www.haoyep.com/posts/digfuzz/ data-title=Digfuzz工具论文调研><i data-svg-src=https://unpkg.com/simple-icons@9.19.0/icons/baidu.svg aria-hidden=true></i></a>
<a href=javascript:void(0); title="分享到 Skype" data-sharer=skype data-url=https://www.haoyep.com/posts/digfuzz/ data-title=Digfuzz工具论文调研><i class="fa-brands fa-skype fa-fw" aria-hidden=true></i></a></span></div></div></div><div class=post-info-more><section class=post-tags><i class="fa-solid fa-tags fa-fw me-1" aria-hidden=true></i><a href=/tags/%E8%AE%BA%E6%96%87/ class=post-tag title="标签 - 论文">论文</a><a href=/tags/%E7%AC%A6%E5%8F%B7%E6%89%A7%E8%A1%8C/ class=post-tag title="标签 - 符号执行">符号执行</a><a href=/tags/%E6%A8%A1%E7%B3%8A%E6%B5%8B%E8%AF%95/ class=post-tag title="标签 - 模糊测试">模糊测试</a></section><section><span><a href=javascript:void(0); onclick=window.history.back()>返回</a></span>&nbsp;|&nbsp;<span><a href=/>主页</a></span></section></div><div class=post-nav><a href=/posts/ptatm-1/ class=post-nav-item rel=prev title=PTATM（一）：初始化工作><i class="fa-solid fa-angle-left fa-fw" aria-hidden=true></i>PTATM（一）：初始化工作</a><a href=/posts/github-graph-beds/ class=post-nav-item rel=next title="使用PicGo + GitHub 搭建 Obsidian 图床">使用PicGo + GitHub 搭建 Obsidian 图床<i class="fa-solid fa-angle-right fa-fw" aria-hidden=true></i></a></div></div><div id=comments><div id=giscus class=comment><script src=https://giscus.app/client.js data-repo=leegical/leegical.github.io data-repo-id=R_kgDOKqVEVg data-category=Announcements data-category-id=DIC_kwDOKqVEVs4Cax6P data-mapping=pathname data-strict=0 data-theme=preferred_color_scheme data-reactions-enabled=1 data-emit-metadata=0 data-input-position=top data-lang=zh-CN data-loading=lazy crossorigin=anonymous async defer></script></div><noscript>Please enable JavaScript to view the comments powered by <a href=https://giscus.app/ rel="external nofollow noopener noreferrer">giscus</a>.</noscript></div></article><aside class=toc id=toc-auto aria-label=目录><h2 class=toc-title>目录&nbsp;<i class="toc-icon fa-solid fa-angle-down fa-fw" aria-hidden=true></i></h2><div class=toc-content id=toc-content-auto></div></aside></main><footer class=footer><div class=footer-container><div class="footer-line copyright" itemscope itemtype=http://schema.org/CreativeWork><i class="fa-regular fa-copyright fa-fw" aria-hidden=true></i>
<span itemprop=copyrightYear>2019 - 2025</span><span class=author itemprop=copyrightHolder>
<a href=https://www.haoyep.com/ target=_blank rel="external nofollow noopener noreferrer">Leehow</a></span><span class="license footer-divider"><a rel="license external nofollow noopener noreferrer" href=https://creativecommons.org/licenses/by-nc/4.0/ target=_blank>CC BY-NC 4.0</a></span></div><div class="footer-line statistics"><span class=site-time title=网站运行中……><i class="fa-solid fa-heartbeat fa-fw animate-icon" aria-hidden=true></i><span class="ms-1 d-none">博客已运行</span><span class="run-times ms-1">网站运行中……</span></span></div><div class="footer-line visitor order-1"><span id=busuanzi_container_site_uv title=总访客数><i class="fa-regular fa-user fa-fw me-1" aria-hidden=true></i><span id=busuanzi_value_site_uv><i class="fa-solid fa-spinner fa-spin fa-fw" aria-hidden=true></i></span></span><span id=busuanzi_container_site_pv class=footer-divider title=总访问量><i class="fa-regular fa-eye fa-fw me-1" aria-hidden=true></i><span id=busuanzi_value_site_pv><i class="fa-solid fa-spinner fa-spin fa-fw" aria-hidden=true></i></span></span></div><div class="footer-line beian order-2"><span class="icp footer-divider"><a href='https://icp.gov.moe/?keyword=20239399' target=_blank>萌ICP备20239399号</a></span></div></div></footer></div><div class=widgets><div class="fixed-buttons animate__faster d-none"><div class="fixed-button back-to-top" role=button aria-label=回到顶部><i class="fa-solid fa-arrow-up fa-fw" aria-hidden=true></i><span class=variant-numeric>0%</span></div><div class="fixed-button view-comments d-none" role=button aria-label=查看评论><i class="fa-solid fa-comment fa-fw" aria-hidden=true></i></div></div><div id=mask></div><div class=reading-progress-bar style=left:0;top:0;--bg-progress:#8581dd;--bg-progress-dark:#fff></div><noscript><div class=noscript-warning>该网站在启用 JavaScript 的情况下效果最佳。</div></noscript></div><link rel=stylesheet href=https://unpkg.com/lightgallery@2.7.2/css/lightgallery-bundle.min.css><link rel=preload href=https://unpkg.com/katex@0.16.10/dist/katex.min.css as=style onload='this.removeAttribute("onload"),this.rel="stylesheet"'><noscript><link rel=stylesheet href=https://unpkg.com/katex@0.16.10/dist/katex.min.css></noscript><link rel=stylesheet href=https://unpkg.com/pace-js@1.2.4/themes/orange/pace-theme-minimal.css><script src=https://unpkg.com/autocomplete.js@0.38.1/dist/autocomplete.min.js defer></script><script src=https://unpkg.com/algoliasearch@4.20.0/dist/algoliasearch-lite.umd.js defer></script><script src=https://unpkg.com/instant.page@5.2.0/instantpage.js async defer type=module></script><script src=https://unpkg.com/lightgallery@2.7.2/lightgallery.min.js defer></script><script src=https://unpkg.com/lightgallery@2.7.2/plugins/thumbnail/lg-thumbnail.min.js defer></script><script src=https://unpkg.com/lightgallery@2.7.2/plugins/zoom/lg-zoom.min.js defer></script><script src=https://unpkg.com/sharer.js@0.5.1/sharer.min.js async defer></script><script src=https://unpkg.com/katex@0.16.10/dist/katex.min.js defer></script><script src=https://unpkg.com/katex@0.16.10/dist/contrib/auto-render.min.js defer></script><script src=https://unpkg.com/katex@0.16.10/dist/contrib/copy-tex.min.js defer></script><script src=https://unpkg.com/katex@0.16.10/dist/contrib/mhchem.min.js defer></script><script src=https://vercount.one/js async defer></script><script src=https://unpkg.com/pace-js@1.2.4/pace.min.js async defer></script><script>window.config={autoBookmark:!0,code:{copyTitle:"复制到剪贴板",editLockTitle:"锁定可编辑代码块",editUnLockTitle:"解锁可编辑代码块",editable:!0,maxShownLines:15},comment:{enable:!0,expired:!1,giscus:{darkTheme:"dark_dimmed",lightTheme:"light",origin:"https://giscus.app"}},enablePWA:!0,lightgallery:!0,math:{delimiters:[{display:!0,left:"$$",right:"$$"},{display:!0,left:"\\[",right:"\\]"},{display:!0,left:"\\begin{equation}",right:"\\end{equation}"},{display:!0,left:"\\begin{equation*}",right:"\\end{equation*}"},{display:!0,left:"\\begin{align}",right:"\\end{align}"},{display:!0,left:"\\begin{align*}",right:"\\end{align*}"},{display:!0,left:"\\begin{alignat}",right:"\\end{alignat}"},{display:!0,left:"\\begin{alignat*}",right:"\\end{alignat*}"},{display:!0,left:"\\begin{gather}",right:"\\end{gather}"},{display:!0,left:"\\begin{CD}",right:"\\end{CD}"},{display:!1,left:"$",right:"$"},{display:!1,left:"\\(",right:"\\)"}],strict:!1},search:{algoliaAppID:"23TF0E394I",algoliaIndex:"index",algoliaSearchKey:"748e3a3e3ef2f537198c57b19d5ff3e6",highlightTag:"em",maxResultLength:10,noResultsFound:"没有找到结果",snippetLength:50,type:"algolia"},siteTime:"2018-02-06T11:15:22+08:00",version:"v0.3.16"}</script><script src=/js/theme.min.js defer></script><script src=/lib/translate.min.js defer></script><script>window.ATConfig={hugoLangCodes:["zh-CN"],hugoLangMap:{"zh-CN":"/posts/digfuzz/"}}</script><script src=/js/translate.fixit.min.js defer></script><script src=/js/custom.min.js defer></script></body></html>